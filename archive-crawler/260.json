{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":168599281,"authorName":"Michael Stack","from":"Michael Stack &lt;stack@...&gt;","replyTo":"LIST","senderId":"DwETnCTj8F83U_tbxWNS3agecg49OHu-XRQYMHLZ9xULDcuMD9xCuCS5AbsVFNpsk6dsClyX60qmrgXqdFAwttp53gGSgbSh","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [archive-crawler] Heritrix Checkpointing High-Level Design","postDate":"1074893303","msgId":260,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQwMTE5MUY3LjkwNjAxMDBAYXJjaGl2ZS5vcmc+","inReplyToHeader":"PDQwMTE3QjJCLjUwNDAwQGFyY2hpdmUub3JnPg==","referencesHeader":"PDQwMERBMjRELjMwMjA0MDNAYXJjaGl2ZS5vcmc+IDw0MDEwODU2OS42MDYwMUBhcmNoaXZlLm9yZz4gPDQwMTE3QjJCLjUwNDAwQGFyY2hpdmUub3JnPg=="},"prevInTopic":259,"nextInTopic":261,"prevInTime":259,"nextInTime":261,"topicId":244,"numMessagesInTopic":13,"msgSnippet":"... Sounds good. ... How about killing off all uninterruptable threads before proceeding w/ checkpointing to save on having to wrap smarts around propagated ","rawEmail":"Return-Path: &lt;stack@...&gt;\r\nX-Sender: stack@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 55259 invoked from network); 23 Jan 2004 21:34:29 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m10.grp.scd.yahoo.com with QMQP; 23 Jan 2004 21:34:29 -0000\r\nReceived: from unknown (HELO ia00524.archive.org) (209.237.232.202)\n  by mta4.grp.scd.yahoo.com with SMTP; 23 Jan 2004 21:34:29 -0000\r\nReceived: (qmail 2645 invoked by uid 100); 23 Jan 2004 21:32:11 -0000\r\nReceived: from b116-dyn-60.archive.org (HELO archive.org) (stack@...@209.237.240.60)\n  by ia14404.archive.org with SMTP; 23 Jan 2004 21:32:11 -0000\r\nMessage-ID: &lt;401191F7.9060100@...&gt;\r\nDate: Fri, 23 Jan 2004 13:28:23 -0800\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.5) Gecko/20031007\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: archive-crawler@yahoogroups.com\r\nReferences: &lt;400DA24D.3020403@...&gt; &lt;40108569.60601@...&gt; &lt;40117B2B.50400@...&gt;\r\nIn-Reply-To: &lt;40117B2B.50400@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Spam-DCC: : \r\nX-Spam-Checker-Version: SpamAssassin 2.63 (2004-01-11) on ia00524.archive.org\r\nX-Spam-Level: \r\nX-Spam-Status: No, hits=-3.5 required=6.0 tests=AWL,BAYES_00 autolearn=ham \n\tversion=2.63\r\nX-eGroups-Remote-IP: 209.237.232.202\r\nFrom: Michael Stack &lt;stack@...&gt;\r\nSubject: Re: [archive-crawler] Heritrix Checkpointing High-Level Design\r\nX-Yahoo-Group-Post: member; u=168599281\r\n\r\nGordon Mohr wrote:\n\n&gt;Michael Stack wrote:\n&gt;... &lt;-- CUT --&gt;\n&gt;\n&gt;But in a crawl of millions of\n&gt;URIs, where each checkpoint could (at worst) cause a few\n&gt;hundred URIs to be double-processed, the overall effect remains\n&gt;negligible.\n&gt;  \n&gt;\n&gt;We&#39;re not in fact planning to be that sloppy, but if in\n&gt;a difficult situation (like hung threads), we have to\n&gt;compromise in that direction, I think that&#39;s &#39;acceptable&#39;\n&gt;duplication.\n&gt;  \n&gt;\nSounds good.\n\n&gt; &gt;&gt; - When an individual worker ToeThread hangs or\n&gt; &gt;&gt;   spins indefinitely in an uninterruptible manner,\n&gt; &gt;&gt;   we will accept whatever small inconsistency\n&gt; &gt;&gt;   might be introduced by ignoring its status and\n&gt; &gt;&gt;   going forward with a checkpoint. (For example,\n&gt; &gt;&gt;   if a buggy Processor at any point in the chain\n&gt; &gt;&gt;   never completes, checkpointing should still\n&gt; &gt;&gt;   be possible, the problem-causing URI should be\n&gt; &gt;&gt;   noted, and our data may suffer side effects of its\n&gt; &gt;&gt;   partial processing.)\n&gt; &gt;\n&gt; &gt; Do we know how to identify a spinning uninterruptable thread\n&gt; &gt; programmatically or is this something a human does?  Will checkpointing\n&gt; &gt; be able to proceed though a thread is unreachable (spinning,\n&gt; &gt; uninterruptable)?  How will it know to skip the problematic thread?\n&gt;\n&gt;  \n&gt;\n&gt;&lt;-- CUT --&gt; \n&gt;  \n&gt;\n\n&gt;This will lead to checkpointing an inconsistent state, but I this\n&gt;inconsistency may be inconsequential (or manually fixable) and\n&gt;thus preferable to the alternative of losing all work since the\n&gt;last checkpoint.\n&gt;\n&gt;  \n&gt;\nHow about killing off all uninterruptable threads before proceeding w/ \ncheckpointing to save on having to wrap smarts around propagated \ncheckpoint invocations to prevent calling into hung threads or for \nhandling the timing-out of checkpointing operations? \n\nBut then killing off threads can put the application into an \nunpredictable state.  We&#39;ll probably have to restart after the \ncheckpointing completes. \n\nIn my experience, killing threads doesn&#39;t resolve deadlock that I \nremember.  Maybe the experience of others is otherwise? \n\nSounds like we need to do some work on making sure threads are \ninterruptable to help make checkpointing the more robust.\n\n(Also see below).\n\n&gt; &gt;&gt; - Logs begin in new files upon each checkpoint; to\n&gt; &gt;&gt;   see the log over the whole crawl, the files must\n&gt; &gt;&gt;   be concatenated. (This makes checkpointing easier\n&gt; &gt;&gt;   but some of the log-viewing admin UI harder.) The\n&gt; &gt;&gt;   Mercator approach is to name the current logs\n&gt; &gt;&gt;   LOGNAME.tmp, then rename them LOGNAME.00001, etc.,\n&gt; &gt;&gt;   after each checkpoint, and we will adopt this\n&gt; &gt;&gt;   same convention.\n&gt; &gt;\n&gt; &gt; So all logs for a crawl will be available under the logging directory?\n&gt; &gt; We don&#39;t want to rotate them out on a period?  Will the UI be expected\n&gt; &gt; to open massive log files (or rather should the UI just show reporting\n&gt; &gt; generated off data logged)?\n&gt;\n&gt;Yes, I believe all the logs should collect in the logging directory\n&gt;until there is a pressing need to move them. Then, we might want to\n&gt;implement -- inside or outside the crawler -- a rotate-away capacity.\n&gt;\n&gt;Such rotation out to another volume shouldn&#39;t have much effect\n&gt;on checkpointing. The UI&#39;s facilities for live-log browsing would\n&gt;have to be made tolerant of such log disappearances.\n&gt;\n&gt;  \n&gt;\nOk.\n\n&gt; &gt;&gt;When user wants to resume from a checkpoint, they can\n&gt; &gt;&gt;browse a list of all known checkpoints (or point crawler\n&gt; &gt;&gt;to a previously unknown checkpoint). Checkpoint is\n&gt; &gt;&gt;first loaded in &#39;paused&#39; mode, allowing state to be\n&gt; &gt;&gt;viewed and paramters to be tuned. Then, crawl can be\n&gt; &gt;&gt;resumed on request.\n&gt; &gt;\n&gt; &gt; At what points during crawling can this above operation be done?  At any\n&gt; &gt; point?  Or just at pause after startup?  Will it be possible for\n&gt; &gt; operator to load a checkpoint while crawler is running (And if so, how\n&gt; &gt; does this work)?\n&gt;\n&gt;The software should be in a &quot;clear&quot; state before a resume-\n&gt;from-checkpoint is attempted: no active crawling, no\n&gt;paused crawl state (or at least no paused crawl state you\n&gt;care to save). This could be immediately after launch, or\n&gt;it could be after some other crawling is paused/saved/cleared.\n&gt;\n&gt;Loading a checkpoint should usually bring the crawler to a\n&gt;&quot;crawl paused&quot; state that is effectively a replica of the\n&gt;state at the time of the checkpoint. Ideally, you could load\n&gt;a checkpoint, use the software admin UI to examine it to see\n&gt;if it really is the one you&#39;d like to resume, perhaps repeat\n&gt;this several times, tinker with some settings, and then hit\n&gt;&#39;begin&#39; to pick up where it left off.\n&gt;  \n&gt;\nLoading a checkpoint destroys the current crawler state.  Makes sense.\n\n&gt; &gt;&gt;The checkpoint begins: each notable component of\n&gt; &gt;&gt;the system -- implementers of the Checkpointable\n&gt; &gt;&gt;interface -- are sent the prepare(checkpointNumber,\n&gt; &gt;&gt;storeDirectory) message. As necessary, they pass\n&gt; &gt;&gt;this to their subcomponents.\n&gt; &gt;\n&gt; &gt; How will you find all implementers of the Checkpointable interface?  Can\n&gt; &gt; any old POJO implement Checkpointable or is it only processors?\n&gt;\n&gt;The CrawlController (which implements Checkpointable) is sent the\n&gt;relevant messages. It propagates these to all components it\n&gt;believes needs checkpointing. Those may further propagate the\n&gt;messages. Any POJO can implement the interface, but that&#39;s no\n&gt;guarantee it will be called; there&#39;s got to be a chain of\n&gt;intentional calls from the CrawlController down.\n&gt;  \n&gt;\nWe might want to institute a check that the interface is implemented \nbefore calling.\n\n&gt; &gt; (Is there a facilty for pausing a crawl or stopping a crawl?  If so, how\n&gt; &gt; is that done?)\n&gt;\n&gt;The existing pause/terminate facility will be touched up as necessary;\n&gt;I believe it currently sets a flag indicating that a pause or termination\n&gt;has been requested, and lets the CrawlController control thread react.\n&gt;  \n&gt;\nI was asking the above because maybe the mechanism for sending these \nmessages might be used by the checkpointing system.\n\nHere is an alternate suggestion for how checkpointing might be done.  \nWhat if we institituted a publish/subscribe eventing mechanism?  The \ncontroller could have a list of all those interested in checkpointing as \nall intererested will have registered themselves as so.  The controller \ncould then send out the relevant messages and be able to iterate over \nthe registered listeners and ask them each in turn if they are ready for \neach stage of checkpointing.  If a subscriber is not responding -- the \ncrawler could wrap all invocations in a timeout -- then we&#39;d know the \nuninterruptable threads.  The checkpoint controller logic would be \nconcentrated in the controller rather than distributed out from the \ncontroller.  It could make the call on what subscribers to pass over \ncheckpointing and when to start the checkpointing transaction.\n\n&gt; &gt; Is it completely up to the Checkpointable implementer how they checkpoint?\n&gt;\n&gt;Yes, though by convention, they should ensure all their state goes\n&gt;into the designated checkpoint directory.\n&gt;\n&gt; &gt;&gt;Generally, the checkpointing of an object involves:\n&gt; &gt;&gt; (1) Writing its important in-memory state to\n&gt; &gt;&gt;     one or more files.\n&gt; &gt;&gt;\n&gt; &gt;&gt; (2) Duplicating any on-disk state to the checkpoint\n&gt; &gt;&gt;     directory. (In some cases, this may be possible\n&gt; &gt;&gt;     with filesystem hard-links rather than actual\n&gt; &gt;&gt;     copies.)\n&gt; &gt;&gt;\n&gt; &gt;\n&gt; &gt; Do you have examples of the above to illustrate how it would work?\n&gt;\n&gt;A trivial example of (1) would be the ARC writer knowing what\n&gt;sequence-number to assign the next ARC file to begin. When asked\n&gt;to checkpoint itself, it would write that bit of state to a file.\n&gt;Similarly, any module collecting a in-memory histogram of\n&gt;interesting resource features would dump its current data in\n&gt;a recoverable fashion to a file.\n&gt;\n&gt;For (2), an example would be the Frontier&#39;s overall pending queue\n&gt;or per-host queues. These might already substantially be on disk,\n&gt;with a small amount in memory. I believe our existing disk-backed\n&gt;Queues can be quickly checkpointed into three files with a minimum\n&gt;of disk writing by:\n&gt;    (a) creating hard links to the up-to-2 constituent backing\n&gt;        disk files (&quot;flip files&quot;)\n&gt;    (b) writing a third file which contains the current lengths of\n&gt;        those backing files, the current pointer to the &#39;head&#39; entry\n&gt;        in one of those files, and the portions of the queue which\n&gt;        live in memory.\n&gt;As activity continues after a checkpoint, the &quot;flip files&quot; grow\n&gt;but are never overwritten, just discarded when their contents are\n&gt;no longer needed. Thus, the hard links will keep the checkpoint\n&gt;data (as well as some extra cruft) alive under a different filename.\n&gt;When a resume becomes necessary the relevant excerpts of the files\n&gt;will be restored.\n&gt;  \n&gt;\nThese help.  You might work them back into your checkpointing proposal.  \nThe queue example will be an interesting problem to solve properly.\n\nGood stuff.\n\nSt.Ack\n\n&gt;Yahoo! Groups Links\n&gt;\n&gt;To visit your group on the web, go to:\n&gt; http://groups.yahoo.com/group/archive-crawler/\n&gt;\n&gt;To unsubscribe from this group, send an email to:\n&gt; archive-crawler-unsubscribe@yahoogroups.com\n&gt;\n&gt;Your use of Yahoo! Groups is subject to:\n&gt; http://docs.yahoo.com/info/terms/ \n&gt;\n&gt;\n&gt;  \n&gt;\n\n\n\n"}}