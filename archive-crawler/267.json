{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":137285340,"authorName":"Gordon Mohr","from":"Gordon Mohr &lt;gojomo@...&gt;","profile":"gojomo","replyTo":"LIST","senderId":"z66_GHHGCoOvdWuzdcp485cHQ7NTZaUPf1iDAorRTN9FtEd4VUJLrTe4H9gNQtYbaAjjhhj29psEPqHaleeS2dAsDQiOXlE","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [archive-crawler] Heritrix Checkpointing High-Level Design","postDate":"1075161271","msgId":267,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQwMTVBOEI3LjEwMjA5MDlAYXJjaGl2ZS5vcmc+","inReplyToHeader":"PDQwMTE5MUY3LjkwNjAxMDBAYXJjaGl2ZS5vcmc+","referencesHeader":"PDQwMERBMjRELjMwMjA0MDNAYXJjaGl2ZS5vcmc+IDw0MDEwODU2OS42MDYwMUBhcmNoaXZlLm9yZz4gPDQwMTE3QjJCLjUwNDAwQGFyY2hpdmUub3JnPiA8NDAxMTkxRjcuOTA2MDEwMEBhcmNoaXZlLm9yZz4="},"prevInTopic":266,"nextInTopic":268,"prevInTime":266,"nextInTime":268,"topicId":244,"numMessagesInTopic":13,"msgSnippet":"... Yes, you re right. We can t count on being able to kill /stop() threads. We can only request interrupts and set variables that the thread should, by","rawEmail":"Return-Path: &lt;gojomo@...&gt;\r\nX-Sender: gojomo@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 16691 invoked from network); 26 Jan 2004 23:55:34 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m16.grp.scd.yahoo.com with QMQP; 26 Jan 2004 23:55:34 -0000\r\nReceived: from unknown (HELO ia00524.archive.org) (209.237.232.202)\n  by mta6.grp.scd.yahoo.com with SMTP; 26 Jan 2004 23:55:34 -0000\r\nReceived: (qmail 32740 invoked by uid 100); 26 Jan 2004 23:52:09 -0000\r\nReceived: from b116-dyn-43.archive.org (HELO archive.org) (gojomo@...@209.237.240.43)\n  by ia14404.archive.org with SMTP; 26 Jan 2004 23:52:09 -0000\r\nMessage-ID: &lt;4015A8B7.1020909@...&gt;\r\nDate: Mon, 26 Jan 2004 15:54:31 -0800\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.6b) Gecko/20031205 Thunderbird/0.4\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: archive-crawler@yahoogroups.com\r\nReferences: &lt;400DA24D.3020403@...&gt; &lt;40108569.60601@...&gt; &lt;40117B2B.50400@...&gt; &lt;401191F7.9060100@...&gt;\r\nIn-Reply-To: &lt;401191F7.9060100@...&gt;\r\nContent-Type: text/plain; charset=us-ascii; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Spam-DCC: : \r\nX-Spam-Checker-Version: SpamAssassin 2.63 (2004-01-11) on ia00524.archive.org\r\nX-Spam-Level: \r\nX-Spam-Status: No, hits=-4.4 required=6.0 tests=AWL,BAYES_00 autolearn=ham \n\tversion=2.63\r\nX-eGroups-Remote-IP: 209.237.232.202\r\nFrom: Gordon Mohr &lt;gojomo@...&gt;\r\nSubject: Re: [archive-crawler] Heritrix Checkpointing High-Level Design\r\nX-Yahoo-Group-Post: member; u=137285340\r\nX-Yahoo-Profile: gojomo\r\n\r\nMichael Stack wrote:\n\n&gt;&gt;This will lead to checkpointing an inconsistent state, but I this\n&gt;&gt;inconsistency may be inconsequential (or manually fixable) and\n&gt;&gt;thus preferable to the alternative of losing all work since the\n&gt;&gt;last checkpoint.\n&gt; \n&gt; How about killing off all uninterruptable threads before proceeding w/ \n&gt; checkpointing to save on having to wrap smarts around propagated \n&gt; checkpoint invocations to prevent calling into hung threads or for \n&gt; handling the timing-out of checkpointing operations? \n&gt; \n&gt; But then killing off threads can put the application into an \n&gt; unpredictable state.  We&#39;ll probably have to restart after the \n&gt; checkpointing completes. \n&gt; \n&gt; In my experience, killing threads doesn&#39;t resolve deadlock that I \n&gt; remember.  Maybe the experience of others is otherwise? \n\nYes, you&#39;re right. We can&#39;t count on being able to &quot;kill&quot;/stop()\nthreads. We can only request interrupts and set variables that\nthe thread should, by design, consult at key points.\n\n&gt; Sounds like we need to do some work on making sure threads are \n&gt; interruptable to help make checkpointing the more robust.\n\nYes, any time a thread does not complete its current stage and\nrespond to an interrupt in a timely manner it is a bug we should\neliminate.\n\n&gt;&gt;The CrawlController (which implements Checkpointable) is sent the\n&gt;&gt;relevant messages. It propagates these to all components it\n&gt;&gt;believes needs checkpointing. Those may further propagate the\n&gt;&gt;messages. Any POJO can implement the interface, but that&#39;s no\n&gt;&gt;guarantee it will be called; there&#39;s got to be a chain of\n&gt;&gt;intentional calls from the CrawlController down.\n&gt; \n&gt; We might want to institute a check that the interface is implemented \n&gt; before calling.\n\nI believe static type checking will suitably enforce this; anything\none component intends to send Checkpointable calls to will already\nbe of a Checkpointable type from the moment it is instantiated (no\ncasting necessary).\n\n\n&gt;&gt;&gt;(Is there a facilty for pausing a crawl or stopping a crawl?  If so, how\n&gt;&gt;&gt;is that done?)\n&gt;&gt;\n&gt;&gt;The existing pause/terminate facility will be touched up as necessary;\n&gt;&gt;I believe it currently sets a flag indicating that a pause or termination\n&gt;&gt;has been requested, and lets the CrawlController control thread react.\n&gt; \n&gt; I was asking the above because maybe the mechanism for sending these \n&gt; messages might be used by the checkpointing system.\n&gt; \n&gt; Here is an alternate suggestion for how checkpointing might be done.  \n&gt; What if we institituted a publish/subscribe eventing mechanism?  The \n&gt; controller could have a list of all those interested in checkpointing as \n&gt; all intererested will have registered themselves as so.  The controller \n&gt; could then send out the relevant messages and be able to iterate over \n&gt; the registered listeners and ask them each in turn if they are ready for \n&gt; each stage of checkpointing.  If a subscriber is not responding -- the \n&gt; crawler could wrap all invocations in a timeout -- then we&#39;d know the \n&gt; uninterruptable threads.  The checkpoint controller logic would be \n&gt; concentrated in the controller rather than distributed out from the \n&gt; controller.  It could make the call on what subscribers to pass over \n&gt; checkpointing and when to start the checkpointing transaction.\n\nI believe checkpointing requires a more tight coupling between related\nobjects and predictable order of operation than an event-based approach\nwould typically involve. Especially as the initial process is worked\nout, it should be more straightforward to have each component hierarchically\nand explicitly trigger checkpointing in its constituent parts, in exactly\nthe right order (which may not be the same order as original instantiation/\ninitialization).\n\nThis also maps better to the resume() operation, which will be very\norder-sensitive.\n\nOnce the process is worked out in at least one concrete form, it may\nthen be clear that a more loosely-coupled event system could serve\nthe same role.\n\n- Gordon\n\n"}}