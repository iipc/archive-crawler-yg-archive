{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":150258428,"authorName":"Allahbaksh","from":"&quot;Allahbaksh&quot; &lt;scholarasad@...&gt;","profile":"scholarasad","replyTo":"LIST","senderId":"UPOF03UerOnEe28OXvvjXFyF2UeY9BD6-LYMBlT2Roww1rmS0KhQLNJaYOp7qXHTwJupcwabFY4ik7A7ecVOZqMxXeItrz6S6Bvu","spamInfo":{"isSpam":false,"reason":"6"},"subject":"Crawler with proxy FetchHTTP  Class problem (proxy problem)","postDate":"1169714839","msgId":3754,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGVwOXFxbys1anBsQGVHcm91cHMuY29tPg=="},"prevInTopic":0,"nextInTopic":3757,"prevInTime":3753,"nextInTime":3755,"topicId":3754,"numMessagesInTopic":2,"msgSnippet":"Hi, Below is my FetchHTTP class. I am unable to crawl the web. We have proxy that requires authentication. Please check whether changes which I have made are","rawEmail":"Return-Path: &lt;scholarasad@...&gt;\r\nX-Sender: scholarasad@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 40559 invoked from network); 25 Jan 2007 08:49:35 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m39a.grp.scd.yahoo.com with QMQP; 25 Jan 2007 08:49:34 -0000\r\nReceived: from unknown (HELO n20a.bullet.scd.yahoo.com) (66.94.237.49)\n  by mta4.grp.scd.yahoo.com with SMTP; 25 Jan 2007 08:49:32 -0000\r\nReceived: from [209.73.164.86] by n20.bullet.scd.yahoo.com with NNFMP; 25 Jan 2007 08:47:21 -0000\r\nReceived: from [66.218.66.79] by t8.bullet.scd.yahoo.com with NNFMP; 25 Jan 2007 08:47:20 -0000\r\nDate: Thu, 25 Jan 2007 08:47:19 -0000\r\nTo: archive-crawler@yahoogroups.com\r\nMessage-ID: &lt;ep9qqo+5jpl@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nX-eGroups-Msg-Info: 1:6:0:0\r\nFrom: &quot;Allahbaksh&quot; &lt;scholarasad@...&gt;\r\nSubject: Crawler with proxy FetchHTTP  Class problem (proxy problem)\r\nX-Yahoo-Group-Post: member; u=150258428; y=c3KV63meY4mjfYmIjurIM9mrx1_XFHIt0WvYQyuXlHhBpOMSa1Y\r\nX-Yahoo-Profile: scholarasad\r\n\r\nHi,\nBelow is my FetchHTTP class. I am unable to crawl the web. We have\nprox=\r\ny that requires authentication. Please check whether changes which\nI have m=\r\nade are at appropriate position.\nRegards.\nAllahbaksh\n\n/* FetchHTTP.java\n *\n=\r\n * $Id: FetchHTTP.java,v 1.113 2006/08/29 22:47:02 stack-sf Exp $\n *\n * Cre=\r\nated on Jun 5, 2003\n *\n * Copyright (C) 2003 Internet Archive.\n *\n * This f=\r\nile is part of the Heritrix web crawler (crawler.archive.org).\n *\n * Heritr=\r\nix is free software; you can redistribute it and/or modify\n * it under the =\r\nterms of the GNU Lesser Public License as published by\n * the Free Software=\r\n Foundation; either version 2.1 of the License, or\n * any later version.\n *=\r\n\n * Heritrix is distributed in the hope that it will be useful,\n * but WITH=\r\nOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY o=\r\nr FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser Public License f=\r\nor more details.\n *\n * You should have received a copy of the GNU Lesser Pu=\r\nblic License\n * along with Heritrix; if not, write to the Free Software\n * =\r\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA \n02111-1307  USA\n =\r\n*/\npackage org.archive.crawler.fetcher;\n\nimport it.unimi.dsi.mg4j.util.Muta=\r\nbleString;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimpo=\r\nrt java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.Obj=\r\nectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.RandomAcc=\r\nessFile;\nimport java.security.KeyManagementException;\nimport java.security.=\r\nKeyStoreException;\nimport java.security.NoSuchAlgorithmException;\nimport ja=\r\nva.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport j=\r\nava.util.ListIterator;\nimport java.util.Map;\nimport java.util.Set;\nimport j=\r\nava.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.net.In=\r\netAddress;\nimport java.net.UnknownHostException;\n\nimport javax.management.A=\r\nttributeNotFoundException;\nimport javax.management.MBeanException;\nimport j=\r\navax.management.ReflectionException;\nimport javax.net.ssl.SSLContext;\nimpor=\r\nt javax.net.ssl.SSLSocketFactory;\nimport javax.net.ssl.TrustManager;\n\nimpor=\r\nt org.apache.commons.httpclient.Cookie;\nimport org.apache.commons.httpclien=\r\nt.Header;\nimport org.apache.commons.httpclient.HostConfiguration;\nimport or=\r\ng.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclien=\r\nt.HttpConnection;\nimport org.apache.commons.httpclient.HttpConnectionManage=\r\nr;\nimport org.apache.commons.httpclient.HttpException;\nimport org.apache.co=\r\nmmons.httpclient.HttpMethod;\nimport org.apache.commons.httpclient.HttpMetho=\r\ndBase;\nimport org.apache.commons.httpclient.HttpState;\nimport org.apache.co=\r\nmmons.httpclient.HttpStatus;\nimport org.apache.commons.httpclient.HttpVersi=\r\non;\nimport org.apache.commons.httpclient.NTCredentials;\nimport org.apache.c=\r\nommons.httpclient.auth.AuthChallengeParser;\nimport org.apache.commons.httpc=\r\nlient.auth.AuthScheme;\nimport org.apache.commons.httpclient.auth.AuthScope;=\r\n\nimport org.apache.commons.httpclient.auth.BasicScheme;\nimport org.apache.c=\r\nommons.httpclient.auth.DigestScheme;\nimport org.apache.commons.httpclient.a=\r\nuth.MalformedChallengeException;\nimport org.apache.commons.httpclient.cooki=\r\ne.CookiePolicy;\nimport org.apache.commons.httpclient.params.HttpClientParam=\r\ns;\nimport org.apache.commons.httpclient.params.HttpConnectionManagerParams;=\r\n\nimport org.apache.commons.httpclient.params.HttpMethodParams;\nimport org.a=\r\npache.commons.httpclient.protocol.Protocol;\nimport org.apache.commons.httpc=\r\nlient.protocol.ProtocolSocketFactory;\nimport org.archive.crawler.Heritrix;\n=\r\nimport org.archive.crawler.datamodel.CoreAttributeConstants;\nimport org.arc=\r\nhive.crawler.datamodel.CrawlHost;\nimport org.archive.crawler.datamodel.Craw=\r\nlOrder;\nimport org.archive.crawler.datamodel.CrawlServer;\nimport org.archiv=\r\ne.crawler.datamodel.CrawlURI;\nimport org.archive.crawler.datamodel.Credenti=\r\nalStore;\nimport org.archive.crawler.datamodel.FetchStatusCodes;\nimport org.=\r\narchive.crawler.datamodel.ServerCache;\nimport org.archive.crawler.datamodel=\r\n.credential.Credential;\nimport org.archive.crawler.datamodel.credential.Cre=\r\ndentialAvatar;\nimport org.archive.crawler.datamodel.credential.Rfc2617Crede=\r\nntial;\nimport org.archive.crawler.event.CrawlStatusListener;\nimport org.arc=\r\nhive.crawler.framework.Filter;\nimport org.archive.crawler.framework.Process=\r\nor;\nimport org.archive.crawler.settings.MapType;\nimport org.archive.crawler=\r\n.settings.SettingsHandler;\nimport org.archive.crawler.settings.SimpleType;\n=\r\nimport org.archive.crawler.settings.StringList;\nimport org.archive.crawler.=\r\nsettings.Type;\nimport org.archive.httpclient.ConfigurableX509TrustManager;\n=\r\nimport org.archive.httpclient.HttpRecorderGetMethod;\nimport org.archive.htt=\r\npclient.HttpRecorderMethod;\nimport org.archive.httpclient.HttpRecorderPostM=\r\nethod;\nimport org.archive.httpclient.SingleHttpConnectionManager;\nimport or=\r\ng.archive.io.ObjectPlusFilesInputStream;\nimport org.archive.io.RecorderLeng=\r\nthExceededException;\nimport org.archive.io.RecorderTimeoutException;\nimport=\r\n org.archive.io.RecorderTooMuchHeaderException;\nimport org.archive.util.Arc=\r\nhiveUtils;\nimport org.archive.util.HttpRecorder;\n\nimport com.sleepycat.bind=\r\n.serial.SerialBinding;\nimport com.sleepycat.bind.serial.StoredClassCatalog;=\r\n\nimport com.sleepycat.bind.tuple.StringBinding;\nimport com.sleepycat.collec=\r\ntions.StoredSortedMap;\nimport com.sleepycat.je.Database;\nimport com.sleepyc=\r\nat.je.DatabaseConfig;\nimport com.sleepycat.je.DatabaseException;\nimport com=\r\n.sleepycat.je.Environment;\n\n/**\n * HTTP fetcher that uses &lt;a\n * href=3D&quot;htt=\r\np://jakarta.apache.org/commons/httpclient/&quot;&gt;Apache Jakarta\nCommons\n * HttpC=\r\nlient&lt;/a&gt; library.\n *\n * @author Gordon Mohr\n * @author Igor Ranitovic\n * @=\r\nauthor others\n * @version $Id: FetchHTTP.java,v 1.113 2006/08/29 22:47:02 s=\r\ntack-sf Exp $\n */\npublic class FetchHTTP extends Processor\nimplements CoreA=\r\nttributeConstants, FetchStatusCodes, CrawlStatusListener {\n    // be robust=\r\n against trivial implementation changes\n    private static final long seria=\r\nlVersionUID =3D\n        ArchiveUtils.classnameBasedUID(FetchHTTP.class,1);\n=\r\n    \n    private static Logger logger =3D\nLogger.getLogger(FetchHTTP.class.=\r\ngetName());\n    public static final String ATTR_HTTP_PROXY_HOST =3D &quot;192.16=\r\n8.208.146&quot;;\n//  public static final String ATTR_HTTP_PROXY_HOST =3D A_HTTP_=\r\nPROXY_HOST;\n    public static final String ATTR_HTTP_PROXY_PORT =3D &quot;80&quot;;\n/=\r\n/    public static final String ATTR_HTTP_PROXY_PORT =3D A_HTTP_PROXY_PORT;=\r\n\n    public static final String ATTR_TIMEOUT_SECONDS =3D &quot;timeout-seconds&quot;;=\r\n\n    public static final String ATTR_SOTIMEOUT_MS =3D &quot;sotimeout-ms&quot;;\n    p=\r\nublic static final String ATTR_MAX_LENGTH_BYTES =3D &quot;max-length-bytes&quot;;\n   =\r\n public static final String ATTR_LOAD_COOKIES =3D\n&quot;load-cookies-from-file&quot;;=\r\n\n    public static final String ATTR_SAVE_COOKIES =3D &quot;save-cookies-to-file=\r\n&quot;;\n    public static final String ATTR_ACCEPT_HEADERS =3D &quot;accept-headers&quot;;=\r\n\n    public static final String ATTR_DEFAULT_ENCODING =3D &quot;default-encoding=\r\n&quot;;\n    public static final String ATTR_SHA1_CONTENT =3D &quot;sha1-content&quot;;\n   =\r\n public static final String ATTR_FETCH_BANDWIDTH_MAX =3D\n&quot;fetch-bandwidth&quot;;=\r\n\n   \n    /**\n     * SSL trust level setting attribute name.\n     */\n    pub=\r\nlic static final String ATTR_TRUST =3D &quot;trust-level&quot;;\n    \n    private stat=\r\nic Integer DEFAULT_TIMEOUT_SECONDS =3D new Integer(1200);\n    private stati=\r\nc Integer DEFAULT_SOTIMEOUT_MS =3D new Integer(20000);\n    private static L=\r\nong DEFAULT_MAX_LENGTH_BYTES =3D new Long(0);\n    private static Integer DE=\r\nFAULT_FETCH_BANDWIDTH_MAX =3D 0;\n\n    /**\n     * This is the default value =\r\npre-1.4. Needs special handling else\n     * treated as negative number doin=\r\ng math later in processing.\n     */\n    private static long OLD_DEFAULT_MAX=\r\n_LENGTH_BYTES =3D\n9223372036854775807L;\n\n    /**\n     * Default character e=\r\nncoding to use for pages that do not specify.\n     */\n    private static St=\r\nring DEFAULT_CONTENT_CHARSET =3D\nHeritrix.DEFAULT_ENCODING;\n\n    /**\n     *=\r\n Default whether to perform on-the-fly SHA1 hashing of\ncontent-bodies.\n    =\r\n */\n    static Boolean DEFAULT_SHA1_CONTENT =3D new Boolean(true);\n    publ=\r\nic static final String SHA1 =3D &quot;sha1&quot;;\n\n    private transient HttpClient h=\r\nttp =3D null;\n\n    /**\n     * How many &#39;instant retries&#39; of HttpRecoverable=\r\nExceptions have\noccurred\n     * \n     * Would like it to be &#39;long&#39;, but lon=\r\ngs aren&#39;t atomic\n     */\n    private int recoveryRetries =3D 0;\n\n    /**\n  =\r\n   * Count of crawl uris handled.\n     * Would like to be &#39;long&#39;, but longs=\r\n aren&#39;t atomic\n     */\n    private int curisHandled =3D 0;\n        \n    /**=\r\n\n     * Filters to apply mid-fetch, just after receipt of the response\n    =\r\n * headers before we start to download body.\n     */\n    public final stati=\r\nc String MIDFETCH_ATTR_FILTERS =3D &quot;midfetch-filters&quot;;\n\n    /**\n     * Inst=\r\nance of midfetchfilters.\n     */\n    private MapType midfetchfilters =3D nu=\r\nll;\n    \n    /**\n     * What to log if midfetch abort.\n     */\n    private =\r\nstatic final String MIDFETCH_ABORT_LOG =3D &quot;midFetchAbort&quot;;\n    \n    public=\r\n static final String ATTR_SEND_CONNECTION_CLOSE =3D\n        &quot;send-connectio=\r\nn-close&quot;;\n    private static final Header HEADER_SEND_CONNECTION_CLOSE =3D\n=\r\n        new Header(&quot;Connection&quot;, &quot;close&quot;);\n    public static final String A=\r\nTTR_SEND_REFERER =3D &quot;send-referer&quot;;\n    public static final String ATTR_SE=\r\nND_RANGE =3D &quot;send-range&quot;;\n    public static final String REFERER =3D &quot;Refe=\r\nrer&quot;;\n    public static final String RANGE =3D &quot;Range&quot;;\n    public static f=\r\ninal String RANGE_PREFIX =3D &quot;bytes=3D0-&quot;;\n    public static final String H=\r\nTTP_SCHEME =3D &quot;http&quot;;\n    public static final String HTTPS_SCHEME =3D &quot;htt=\r\nps&quot;;\n    \n    public static final String ATTR_IGNORE_COOKIES =3D &quot;ignore-co=\r\nokies&quot;;\n    private static Boolean DEFAULT_IGNORE_COOKIES =3D new Boolean(f=\r\nalse);\n\n    public static final String ATTR_BDB_COOKIES =3D &quot;use-bdb-for-co=\r\nokies&quot;;\n    private static Boolean DEFAULT_BDB_COOKIES =3D new Boolean(true=\r\n);\n    \n    public static final String ATTR_LOCAL_ADDRESS =3D &quot;bind-address=\r\n&quot;;\n    \n    /**\n     * Database backing cookie map, if using BDB\n     */\n  =\r\n  protected Database cookieDb; \n    /**\n     * Name of cookie BDB Database\n=\r\n     */\n    public static final String COOKIEDB_NAME =3D &quot;http_cookies&quot;;\n  =\r\n  \n    static {\n    \tProtocol.registerProtocol(&quot;http&quot;, new Protocol(&quot;http&quot;,=\r\n\n            new HeritrixProtocolSocketFactory(), 80));\n    \ttry {\n\t\t\tProto=\r\ncol.registerProtocol(&quot;https&quot;,\n\t\t\t    new Protocol(&quot;https&quot;, ((ProtocolSocket=\r\nFactory)\n\t\t\t        new HeritrixSSLProtocolSocketFactory()), 443));\n\t\t} cat=\r\nch (KeyManagementException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (KeyStore=\r\nException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (NoSuchAlgorithmException =\r\ne) {\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    static final String SERVER_CACHE=\r\n_KEY =3D &quot;heritrix.server.cache&quot;;\n    static final String SSL_FACTORY_KEY =\r\n=3D &quot;heritrix.ssl.factory&quot;;\n    \n    /***\n     * Socket factory that has th=\r\ne configurable trust manager installed.\n     */\n    private SSLSocketFactor=\r\ny sslfactory =3D null;\n    \n\n    /**\n     * Constructor.\n     *\n     * @par=\r\nam name Name of this processor.\n     */\n    public FetchHTTP(String name) {=\r\n\n        super(name, &quot;HTTP Fetcher&quot;);\n        this.midfetchfilters =3D (Map=\r\nType) addElementToDefinition(\n            new MapType(MIDFETCH_ATTR_FILTERS=\r\n, &quot;Filters applied after&quot; +\n                &quot; receipt of HTTP response head=\r\ners but before we start\nto&quot; +\n                &quot; download the body. If any f=\r\nilter returns&quot; +\n                &quot; FALSE, the fetch is aborted. Prerequisit=\r\nes such as&quot; +\n                &quot; robots.txt by-pass filtering (i.e. they can=\r\nnot be&quot; +\n                &quot; midfetch aborted.&quot;, Filter.class));\n// see [ 13=\r\n79040 ] regex for midfetch filter not being stored in crawl\norder\n// http:/=\r\n/sourceforge.net/support/tracker.php?aid=3D1379040\n//        this.midfetchf=\r\nilters.setExpertSetting(true);\n        \n        addElementToDefinition(new =\r\nSimpleType(ATTR_TIMEOUT_SECONDS,\n            &quot;If the fetch is not completed=\r\n in this number of seconds,&quot;\n            + &quot; give up (and retry later). For=\r\n optimal configuration, &quot; +\n            &quot; ensure this value is &gt; &quot; + ATTR_T=\r\nIMEOUT_SECONDS + &quot;.&quot;,\n            DEFAULT_TIMEOUT_SECONDS));\n        Type e=\r\n =3D addElementToDefinition(new SimpleType(ATTR_SOTIMEOUT_MS,\n            &quot;=\r\nIf the socket is unresponsive for this number of\nmilliseconds, &quot; +\n        =\r\n    &quot; give up.  Set to zero for no timeout (Not.&quot; +\n            &quot; recommend=\r\ned. Could hang a thread on an unresponsive\nserver).&quot; +\n            &quot; This t=\r\nimeout is used timing out socket opens &quot; +\n            &quot; and for timing out=\r\n each socket read.  Make sure this &quot; +\n            &quot; value is &lt; &quot; + ATTR_TI=\r\nMEOUT_SECONDS + &quot; for optimal &quot; +\n            &quot; configuration: ensures at l=\r\neast one retry read.&quot;,\n                DEFAULT_SOTIMEOUT_MS));\n        e.se=\r\ntExpertSetting(true);\n        e =3D addElementToDefinition(new\nSimpleType(A=\r\nTTR_FETCH_BANDWIDTH_MAX,\n            &quot;The maximum KB/sec to use when fetchi=\r\nng data from a\nserver. &quot; +\n            &quot;0 means no maximum.  Default: &quot;+ DE=\r\nFAULT_FETCH_BANDWIDTH_MAX\n             + &quot;.&quot;, DEFAULT_FETCH_BANDWIDTH_MAX))=\r\n;\n        e.setExpertSetting(true);\n        e.setOverrideable(true);\n      =\r\n  addElementToDefinition(new SimpleType(ATTR_MAX_LENGTH_BYTES,\n            =\r\n&quot;Maximum length in bytes to fetch.&#92;n&quot; +\n            &quot;Fetch is truncated at =\r\nthis length. A value of 0 means no\nlimit.&quot;,\n            DEFAULT_MAX_LENGTH_=\r\nBYTES));\n        e =3D addElementToDefinition(new SimpleType(ATTR_IGNORE_CO=\r\nOKIES,\n            &quot;Disable cookie-handling.&quot;, DEFAULT_IGNORE_COOKIES));\n  =\r\n      e.setOverrideable(true);\n        e.setExpertSetting(true);\n        e =\r\n=3D addElementToDefinition(new SimpleType(ATTR_BDB_COOKIES,\n               =\r\n &quot;Store cookies in BDB-backed map.&quot;, DEFAULT_BDB_COOKIES));\n        e.setEx=\r\npertSetting(true);\n\n        e =3D addElementToDefinition(new SimpleType(ATT=\r\nR_LOAD_COOKIES,\n            &quot;File to preload cookies from&quot;, &quot;&quot;));\n        e=\r\n.setExpertSetting(true);\n        e =3D addElementToDefinition(new SimpleTyp=\r\ne(ATTR_SAVE_COOKIES,\n            &quot;When crawl finishes save cookies to this =\r\nfile&quot;, &quot;&quot;));\n        e.setExpertSetting(true);\n        e =3D addElementToDe=\r\nfinition(new SimpleType(ATTR_TRUST,\n            &quot;SSL certificate trust leve=\r\nl.  Range is from the default\n&#39;open&#39;&quot;\n            + &quot; (trust all certs incl=\r\nuding expired, selfsigned, and\nthose for&quot;\n            + &quot; which we do not h=\r\nave a CA) through &#39;loose&#39; (trust all\nvalid&quot;\n            + &quot; certificates in=\r\ncluding selfsigned), &#39;normal&#39; (all valid&quot;\n            + &quot; certificates not =\r\nincluding selfsigned) to &#39;strict&#39;\n(Cert is&quot;\n            + &quot; valid and DN mu=\r\nst match servername)&quot;,\n            ConfigurableX509TrustManager.DEFAULT,\n  =\r\n          ConfigurableX509TrustManager.LEVELS_AS_ARRAY));\n        e.setOver=\r\nrideable(false);\n        e.setExpertSetting(true);\n        e =3D addElement=\r\nToDefinition(new StringList(ATTR_ACCEPT_HEADERS,\n            &quot;Accept Header=\r\ns to include in each request. Each must be the&quot;\n            + &quot; complete he=\r\nader, e.g., &#39;Accept-Language: en&#39;&quot;));\n        e.setExpertSetting(true);\n   =\r\n     e =3D addElementToDefinition(new SimpleType(ATTR_HTTP_PROXY_HOST,\n    =\r\n        &quot;Proxy host IP (set only if needed).&quot;, &quot;&quot;));\n        e.setExpertSet=\r\nting(true);\n        e =3D addElementToDefinition(new SimpleType(ATTR_HTTP_P=\r\nROXY_PORT,\n            &quot;Proxy port (set only if needed)&quot;, &quot;&quot;));\n        e.s=\r\netExpertSetting(true);\n        e =3D addElementToDefinition(new SimpleType(=\r\nATTR_DEFAULT_ENCODING,\n            &quot;The character encoding to use for files=\r\n that do not have\none&quot; +\n            &quot; specified in the HTTP response heade=\r\nrs.  Default: &quot; +\n            DEFAULT_CONTENT_CHARSET + &quot;.&quot;,\n            DE=\r\nFAULT_CONTENT_CHARSET));\n        e.setExpertSetting(true);\n        e =3D ad=\r\ndElementToDefinition(new SimpleType(ATTR_SHA1_CONTENT,\n                &quot;Whe=\r\nther or not to perform an on-the-fly SHA1 hash of&quot; +\n                &quot;retri=\r\neved content-bodies.&quot;,\n                DEFAULT_SHA1_CONTENT));\n        e.se=\r\ntExpertSetting(true);\n        e =3D addElementToDefinition(new\nSimpleType(A=\r\nTTR_SEND_CONNECTION_CLOSE,\n            &quot;Send &#39;Connection: close&#39; header wit=\r\nh every request.&quot;,\n             new Boolean(true)));\n        e.setOverridea=\r\nble(true);\n        e.setExpertSetting(true);\n        e =3D addElementToDefi=\r\nnition(new SimpleType(ATTR_SEND_REFERER,\n             &quot;Send &#39;Referer&#39; heade=\r\nr with every request.&#92;n&quot; +\n             &quot;The &#39;Referer&#39; header contans the l=\r\nocation the crawler\ncame &quot; +\n             &quot; from, &quot; +\n             &quot;the pag=\r\ne the current URI was discovered in. The\n&#39;Referer&#39; &quot; +\n             &quot;usuall=\r\ny is &quot; +\n             &quot;logged on the remote server and can be of assistance=\r\n to &quot; +\n             &quot;webmasters trying to figure how a crawler got to a &quot; =\r\n+\n             &quot;particular area on a site.&quot;,\n             new Boolean(true)=\r\n));\n        e.setOverrideable(true);\n        e.setExpertSetting(true);\n    =\r\n    e =3D addElementToDefinition(new SimpleType(ATTR_SEND_RANGE,\n          =\r\n    &quot;Send &#39;Range&#39; header when a limit (&quot; +\nATTR_MAX_LENGTH_BYTES +\n        =\r\n      &quot;) on document size.&#92;n&quot; +\n              &quot;Be polite to the HTTP server=\r\ns and send the &#39;Range&#39;\nheader,&quot; +\n              &quot;stating that you are only =\r\ninterested in the first n\nbytes. &quot; +\n              &quot;Only pertinent if &quot; + A=\r\nTTR_MAX_LENGTH_BYTES + &quot; &gt; 0. &quot; +\n              &quot;Sending the &#39;Range&#39; header=\r\n results in a &quot; +\n              &quot;&#39;206 Partial Content&#39; status response, whi=\r\nch is better\nthan &quot; +\n              &quot;just cutting the response mid-download=\r\n. On rare\noccasion, &quot; +\n              &quot; sending &#39;Range&#39; will &quot; +\n          =\r\n    &quot;generate &#39;416 Request Range Not Satisfiable&#39; response.&quot;,\n             =\r\n new Boolean(false)));\n           e.setOverrideable(true);\n           e.set=\r\nExpertSetting(true);\n           e =3D addElementToDefinition(new SimpleType=\r\n(ATTR_LOCAL_ADDRESS,\n               &quot;Local IP address or hostname to use wh=\r\nen making\nconnections &quot; +\n               &quot;(binding sockets). When not speci=\r\nfied, uses default\nlocal&quot; +\n               &quot;address(es).&quot;, &quot;&quot;));\n          =\r\n e.setExpertSetting(true);\n           System.out.println(&quot;In Constructor&quot;);=\r\n\n    }\n\n    protected void innerProcess(final CrawlURI curi)\n    throws Int=\r\nerruptedException {\n    \t//TODO canFetch \n    \tSystem.out.println(&quot;&quot;);\n    =\r\n    if (!canFetch(curi)) {\n            // Cannot fetch this, due to protoco=\r\nl, retries, or other\nproblems\n            return;\n        }\n\n        this.c=\r\nurisHandled++;\n\n        // Note begin time\n        curi.putLong(A_FETCH_BEG=\r\nAN_TIME, System.currentTimeMillis());\n\n        // Get a reference to the Ht=\r\ntpRecorder that is set into this\nToeThread.\n        HttpRecorder rec =3D Ht=\r\ntpRecorder.getHttpRecorder();\n        \n        // Shall we get a digest on =\r\nthe content downloaded?\n        boolean sha1Content =3D ((Boolean)getUnchec=\r\nkedAttribute(curi,\n            ATTR_SHA1_CONTENT)).booleanValue();\n        =\r\nif(sha1Content) {\n            rec.getRecordedInput().setSha1Digest();\n     =\r\n   } else {\n            // clear\n            rec.getRecordedInput().setDige=\r\nst(null);\n        }\n        \n        // Below we do two inner classes that =\r\nadd check of midfetch\n        // filters just as we&#39;re about to receive the=\r\n response body.\n        String curiString =3D curi.getUURI().toString();\n  =\r\n      HttpMethodBase method =3D null;\n        if (curi.isPost()) {\n        =\r\n    method =3D new HttpRecorderPostMethod(curiString, rec) {\n              =\r\n  protected void readResponseBody(HttpState state,\n                        =\r\nHttpConnection conn)\n                throws IOException, HttpException {\n  =\r\n                  addResponseContent(this, curi);\n                    if (c=\r\nheckMidfetchAbort(curi,\nthis.httpRecorderMethod, conn)) {\n                 =\r\n       doAbort(curi, this, MIDFETCH_ABORT_LOG);\n                    } else =\r\n{\n                        super.readResponseBody(state, conn);\n            =\r\n        }\n                }\n            };\n        } else {\n            met=\r\nhod =3D new HttpRecorderGetMethod(curiString, rec) {\n                protec=\r\nted void readResponseBody(HttpState state,\n                        HttpConn=\r\nection conn)\n                throws IOException, HttpException {\n          =\r\n          addResponseContent(this, curi);\n                    if (checkMidf=\r\netchAbort(curi, this.httpRecorderMethod,\n                            conn))=\r\n {\n                        doAbort(curi, this, MIDFETCH_ABORT_LOG);\n       =\r\n             } else {\n                        super.readResponseBody(state,=\r\n conn);\n                    }\n                }\n            };\n        }\n\n =\r\n       HostConfiguration customConfigOrNull =3D configureMethod(curi,\nmetho=\r\nd);\n        \n        // Set httpRecorder into curi. Subsequent code both he=\r\nre and later\n        // in extractors expects to find the HttpRecorder in t=\r\nhe CrawlURI.\n        curi.setHttpRecorder(rec);\n        \n        // Populat=\r\ne credentials. Set config so auth. is not automatic.\n        boolean addedC=\r\nredentials =3D populateCredentials(curi, method);\n        method.setDoAuthe=\r\nntication(addedCredentials);\n        \n        try {\n        \tSystem.out.pri=\r\nntln(&quot;Proxy Configured in Try block&quot;);;\n        \thttp.getState().setProxyCr=\r\nedentials(null,null,\n                   new\nNTCredentials(&quot;allahbaksh_asadu=\r\nllah&quot;,&quot;123@naheed&quot;,&quot;192.168.208.146&quot;,&quot;itlinfosys&quot;));\n            this.http.=\r\nexecuteMethod(customConfigOrNull, method);\n        } catch (RecorderTooMuch=\r\nHeaderException ex) {\n            // when too much header material, abort l=\r\nike other truncations\n            doAbort(curi, method, HEADER_TRUNC);\n    =\r\n    } catch (IOException e) {\n        \tfailedExecuteCleanup(method, curi, e=\r\n);\n        \treturn;\n        } catch (ArrayIndexOutOfBoundsException e) {\n  =\r\n          // For weird windows-only ArrayIndex exceptions in native\n       =\r\n     // code... see\n            // http://forum.java.sun.com/thread.jsp?for=\r\num=3D11&thread=3D378356\n            // treating as if it were an IOExceptio=\r\nn\n            failedExecuteCleanup(method, curi, e);\n            return;\n  =\r\n      }\n        \n        // set softMax on bytes to get (if implied by cont=\r\nent-length) \n        long softMax =3D method.getResponseContentLength();\n  =\r\n      \n        // set hardMax on bytes (if set by operator)\n        long ha=\r\nrdMax =3D getMaxLength(curi);\n\n\t// Get max fetch rate (bytes/ms). It comes =\r\nin in KB/sec, which\n\t// requires nothing to normalize.\n        int maxFetch=\r\nRate =3D getMaxFetchRate(curi);\n\n        try {\n            if (!method.isAb=\r\norted()) {\n                // Force read-to-end, so that any socket hangs o=\r\nccur here,\n                // not in later modules.\n                rec.get=\r\nRecordedInput().readFullyOrUntil(softMax,\n                        hardMax, =\r\n1000 * getTimeout(curi), maxFetchRate);\n            }\n        } catch (Reco=\r\nrderTimeoutException ex) {\n            doAbort(curi, method, TIMER_TRUNC);\n=\r\n        } catch (RecorderLengthExceededException ex) {\n            doAbort(=\r\ncuri, method, LENGTH_TRUNC);\n        } catch (IOException e) {\n            =\r\ncleanup(curi, e, &quot;readFully&quot;, S_CONNECT_LOST);\n            return;\n        =\r\n} catch (ArrayIndexOutOfBoundsException e) {\n            // For weird windo=\r\nws-only ArrayIndex exceptions from\nnative code\n            // see\nhttp://fo=\r\nrum.java.sun.com/thread.jsp?forum=3D11&thread=3D378356\n            // treat=\r\ning as if it were an IOException\n            cleanup(curi, e, &quot;readFully&quot;, =\r\nS_CONNECT_LOST);\n            return;\n        } finally {\n            // ens=\r\nure recording has stopped\n            rec.closeRecorders();\n            if =\r\n(!method.isAborted()) {\n                method.releaseConnection();\n       =\r\n     }\n            // Note completion time\n            curi.putLong(A_FETCH=\r\n_COMPLETED_TIME,\nSystem.currentTimeMillis());\n            // Set the respon=\r\nse charset into the HttpRecord if available.\n            setCharacterEncodi=\r\nng(rec, method);\n            curi.setContentSize(rec.getRecordedInput().get=\r\nSize());\n        }\n        \n        curi.setContentDigest(SHA1,\nrec.getReco=\r\nrdedInput().getDigestValue());\n        if (logger.isLoggable(Level.INFO)) {=\r\n\n            logger.info((curi.isPost()? &quot;POST&quot;: &quot;GET&quot;) + &quot; &quot; +\n           =\r\n     curi.getUURI().toString() + &quot; &quot; + method.getStatusCode() +\n           =\r\n     &quot; &quot; + rec.getRecordedInput().getSize() + &quot; &quot; +\n                curi.ge=\r\ntContentType());\n        }\n\n        if (curi.isSuccess() && addedCredential=\r\ns) {\n            // Promote the credentials from the CrawlURI to the\nCrawlS=\r\nerver\n            // so they are available for all subsequent CrawlURIs on =\r\nthis\n            // server.\n            promoteCredentials(curi);\n         =\r\n   if (logger.isLoggable(Level.FINE)) {\n                // Print out the co=\r\nokie.  Might help with the debugging.\n                Header setCookie =3D =\r\nmethod.getResponseHeader(&quot;set-cookie&quot;);\n                if (setCookie !=3D =\r\nnull) {\n                    logger.fine(setCookie.toString().trim());\n     =\r\n           }\n            }\n        } else if (method.getStatusCode() =3D=3D=\r\n HttpStatus.SC_UNAUTHORIZED) {\n            // 401 is not &#39;success&#39;.\n       =\r\n     handle401(method, curi);\n        }\n        \n        if (rec.getRecorde=\r\ndInput().isOpen()) {\n            logger.severe(curi.toString() + &quot; RIS stil=\r\nl open. Should\nhave&quot; +\n                &quot; been closed by method release: &quot; +=\r\n\n                Thread.currentThread().getName());\n            try {\n     =\r\n           rec.getRecordedInput().close();\n            } catch (IOException=\r\n e) {\n                logger.log(Level.SEVERE,&quot;second-chance RIS close\nfail=\r\ned&quot;,e);\n            }\n        }\n    }\n    \n    protected void doAbort(Crawl=\r\nURI curi, HttpMethod method,\n            String annotation) {\n        curi.=\r\naddAnnotation(annotation);\n        curi.getHttpRecorder().close();\n        =\r\nmethod.abort();\n    }\n    \n    protected boolean checkMidfetchAbort(CrawlUR=\r\nI curi,\n            HttpRecorderMethod method, HttpConnection conn) {\n     =\r\n   if (curi.isPrerequisite() || filtersAccept(midfetchfilters,\ncuri)) {\n   =\r\n         return false;\n        }\n        method.markContentBegin(conn);\n   =\r\n     return true;\n    }\n    \n    /**\n     * This method populates &lt;code&gt;cur=\r\ni&lt;/code&gt; with response status and\n     * content type.\n     * @param curi C=\r\nrawlURI to populate.\n     * @param method Method to get response status and=\r\n headers from.\n     */\n    protected void addResponseContent (HttpMethod me=\r\nthod, CrawlURI curi) {\n        curi.setFetchStatus(method.getStatusCode());=\r\n\n        Header ct =3D method.getResponseHeader(&quot;content-type&quot;);\n        cu=\r\nri.setContentType((ct =3D=3D null)? null: ct.getValue());\n        // Save m=\r\nethod into curi too.  Midfetch filters may want to\nleverage\n        // info=\r\n in here.\n        curi.putObject(A_HTTP_TRANSACTION, method);\n    }\n\n    /*=\r\n*\n     * Set the character encoding based on the result headers or default.=\r\n\n     *\n     * The HttpClient returns its own default encoding (&quot;ISO-8859-1=\r\n&quot;)\nif one\n     * isn&#39;t specified in the Content-Type response header. We gi=\r\nve\nthe user\n     * the option of overriding this, so we need to detect the =\r\ncase\nwhere the\n     * default is returned.\n     *\n     * Now, it may well b=\r\ne the case that the default returned by\nHttpClient\n     * and the default d=\r\nefined by the user are the same.\n     * \n     * @param rec Recorder for thi=\r\ns request.\n     * @param method Method used for the request.\n     */\n    pr=\r\nivate void setCharacterEncoding(final HttpRecorder rec,\n        final HttpM=\r\nethod method) {\n        String encoding =3D null;\n\n        try {\n          =\r\n  encoding =3D ((HttpMethodBase) method).getResponseCharSet();\n            =\r\nif (encoding =3D=3D null ||\n                    encoding.equals(DEFAULT_CON=\r\nTENT_CHARSET)) {\n                encoding =3D (String) getAttribute(ATTR_DE=\r\nFAULT_ENCODING);\n            }\n        } catch (Exception e) {\n            =\r\nlogger.warning(&quot;Failed get default encoding: &quot; +\n                e.getLocal=\r\nizedMessage());\n        }\n        rec.setCharacterEncoding(encoding);\n    }=\r\n\n\n    /**\n     * Cleanup after a failed method execute.\n     * @param curi =\r\nCrawlURI we failed on.\n     * @param method Method we failed on.\n     * @pa=\r\nram exception Exception we failed with.\n     */\n    private void failedExec=\r\nuteCleanup(final HttpMethod method,\n            final CrawlURI curi, final =\r\nException exception) {\n        cleanup(curi, exception, &quot;executeMethod&quot;, S_=\r\nCONNECT_FAILED);\n        method.releaseConnection();\n    }\n    \n    /**\n   =\r\n  * Cleanup after a failed method execute.\n     * @param curi CrawlURI we f=\r\nailed on.\n     * @param exception Exception we failed with.\n     * @param m=\r\nessage Message to log with failure.\n     * @param status Status to set on t=\r\nhe fetch.\n     */\n    private void cleanup(final CrawlURI curi, final Excep=\r\ntion exception,\n            final String message, final int status) {\n     =\r\n   curi.addLocalizedError(this.getName(), exception, message);\n        curi=\r\n.setFetchStatus(status);\n        curi.getHttpRecorder().close();\n    }\n\n   =\r\n /**\n     * Can this processor fetch the given CrawlURI. May set a fetch\n  =\r\n   * status if this processor would usually handle the CrawlURI,\n     * but=\r\n cannot in this instance.\n     *\n     * @param curi\n     * @return True if =\r\nprocessor can fetch.\n     */\n    private boolean canFetch(CrawlURI curi) {\n=\r\n        if(curi.getFetchStatus()&lt;0) {\n            // already marked as erro=\r\nred, this pass through\n            // skip to end\n           \ncuri.skipToPr=\r\nocessorChain(getController().getPostprocessorChain());\n            return f=\r\nalse;             \n        }\n        System.out.println(&quot;&quot;);\n        String=\r\n scheme =3D curi.getUURI().getScheme();\n         if (!(scheme.equals(&quot;http&quot;=\r\n) || scheme.equals(&quot;https&quot;))) {\n             // handles only plain http and=\r\n https\n             return false;\n         }\n         CrawlHost host =3D\nge=\r\ntController().getServerCache().getHostFor(curi);\n         // make sure the =\r\ndns lookup succeeded\n         if (host.getIP() =3D=3D null && host.hasBeenL=\r\nookedUp()) {\n             curi.setFetchStatus(S_DOMAIN_PREREQUISITE_FAILURE=\r\n);\n             return false;\n         }\n        return true;\n    }\n\n    /*=\r\n*\n     * Configure the HttpMethod setting options and headers.\n     *\n     =\r\n* @param curi CrawlURI from which we pull configuration.\n     * @param meth=\r\nod The Method to configure.\n     */\n    protected HostConfiguration configu=\r\nreMethod(CrawlURI curi,\nHttpMethod method) {\n        // Don&#39;t auto-follow r=\r\nedirects\n        method.setFollowRedirects(false);\n        \n//        // se=\r\nt soTimeout\n//        method.getParams().setSoTimeout(\n//                ((=\r\nInteger) getUncheckedAttribute(curi,\nATTR_SOTIMEOUT_MS))\n//                =\r\n        .intValue());\n        \n        // Set cookie policy.\n        method=\r\n.getParams().setCookiePolicy(\n            (((Boolean)getUncheckedAttribute(=\r\ncuri, ATTR_IGNORE_COOKIES)).\n                booleanValue())?\n             =\r\n       CookiePolicy.IGNORE_COOKIES:\n                CookiePolicy.BROWSER_CO=\r\nMPATIBILITY);\n\n        // Use only HTTP/1.0 (to avoid receiving chunked res=\r\nponses)\n        method.getParams().setVersion(HttpVersion.HTTP_1_0);\n\n     =\r\n   CrawlOrder order =3D getSettingsHandler().getOrder();\n        String use=\r\nrAgent =3D curi.getUserAgent();\n        if (userAgent =3D=3D null) {\n      =\r\n      userAgent =3D order.getUserAgent(curi);\n        }\n        method.setR=\r\nequestHeader(&quot;User-Agent&quot;, userAgent);\n        method.setRequestHeader(&quot;Fro=\r\nm&quot;, order.getFrom(curi));\n        \n        // Set retry handler.\n        me=\r\nthod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER,\n            n=\r\new HeritrixHttpMethodRetryHandler());\n        \n        final long maxLength=\r\n =3D getMaxLength(curi);\n        if(maxLength &gt; 0 &&\n                ((Bool=\r\nean)getUncheckedAttribute(curi, ATTR_SEND_RANGE)).\n                    bool=\r\neanValue()) {\n            method.addRequestHeader(RANGE,\n                RA=\r\nNGE_PREFIX.concat(Long.toString(maxLength - 1)));\n        }\n        \n      =\r\n  if (((Boolean)getUncheckedAttribute(curi,\n                ATTR_SEND_CONNE=\r\nCTION_CLOSE)).booleanValue()) {\n            method.addRequestHeader(HEADER_=\r\nSEND_CONNECTION_CLOSE);\n        }\n        \n        if (((Boolean)getUncheck=\r\nedAttribute(curi,\n                ATTR_SEND_REFERER)).booleanValue()) {\n   =\r\n         // RFC2616 says no referer header if referer is https and\nthe url\n=\r\n            // is not\n            String via =3D curi.flattenVia();\n       =\r\n     if (via !=3D null && via.length() &gt; 0 &&\n                !(via.startsW=\r\nith(HTTPS_SCHEME) &&\n                    curi.getUURI().getScheme().equals(=\r\nHTTP_SCHEME))) {\n                method.setRequestHeader(REFERER, via);\n   =\r\n         }\n        }\n        \n        // TODO: What happens if below method=\r\n adds a header already\n        // added above: e.g. Connection, Range, or R=\r\neferer?\n        setAcceptHeaders(curi, method);\n        \n        return con=\r\nfigureProxy(curi);\n    }\n\n    /**\n     * Setup proxy, based on attributes i=\r\nn CrawlURI and settings, \n     * for this CrawlURI only. \n     * @return Ho=\r\nstConfiguration customized as necessary, or null if no\n     * customization=\r\n required\n     */\n    private HostConfiguration configureProxy(CrawlURI cur=\r\ni) {\n        String proxy =3D (String) getAttributeEither(curi,\nATTR_HTTP_P=\r\nROXY_HOST);\n        int port =3D -1; \n        if(proxy.length()=3D=3D0) {\n =\r\n           proxy =3D null; \n        } else {\n            String portString =\r\n=3D (String)getAttributeEither(curi,\nATTR_HTTP_PROXY_PORT);\n            por=\r\nt =3D portString.length()&gt;0 ?\nInteger.parseInt(portString) : -1; \n        }=\r\n\n        \n        //Changes made here. \n        System.out.println(&quot;Initial=\r\n Changes&quot;);\n        http.getState().setProxyCredentials(null,null,\n        =\r\n     new\nNTCredentials(&quot;allahbaksh_asadullah&quot;,&quot;123@naheed&quot;,&quot;172.25.232.130&quot;=\r\n,&quot;itlinfosys&quot;));\n        HostConfiguration config =3D this.http.getHostConf=\r\niguration();\n        if(config.getProxyHost() =3D=3D proxy && config.getPro=\r\nxyPort() =3D=3D\nport) {\n            // no change,lp\n            return null=\r\n; \n        }\n        if (proxy !=3D null && proxy.equals(config.getProxyHos=\r\nt()) \n                && config.getProxyPort() =3D=3D port) {\n            /=\r\n/ no change\n            return null; \n        }\n        config =3D new Host=\r\nConfiguration(config); // copy of config\n      //  config.setProxy(&quot;192.168=\r\n.208.146&quot;,80);\n        //config.setProxy(&quot;10.136.64.194&quot;,80);\n        \n    =\r\n    \n        \n        return config; \n    }\n\n    /**\n     * Get a value eit=\r\nher from inside the CrawlURI instance, or from \n     * settings (module att=\r\nributes). \n     * \n     * @param curi CrawlURI to consult\n     * @param key=\r\n key to lookup\n     * @return value from either CrawlURI (preferred) or set=\r\ntings\n     */\n    protected Object getAttributeEither(CrawlURI curi, String=\r\n key) {\n        Object obj =3D curi!=3Dnull ? curi.getObject(key) : null;\n =\r\n       if(obj=3D=3Dnull) {\n            obj =3D getUncheckedAttribute(curi, =\r\nkey);\n        }\n        return obj;\n    }\n\n    /**\n     * Add credentials i=\r\nf any to passed &lt;code&gt;method&lt;/code&gt;.\n     *\n     * Do credential handling. =\r\n Credentials are in two places.  1.\nCredentials\n     * that succeeded are a=\r\ndded to the CrawlServer (Or rather, avatars for\n     * credentials are what=\r\ns added because its not safe to keep around\n     * references to credential=\r\ns).  2. Credentials to be tried are in\nthe curi.\n     * Returns true if fou=\r\nnd credentials to be tried.\n     *\n     * @param curi Current CrawlURI.\n   =\r\n  * @param method The method to add to.\n     * @return True if prepopulated=\r\n &lt;code&gt;method&lt;/code&gt; with\ncredentials AND the\n     * credentials came from =\r\nthe &lt;code&gt;curi&lt;/code&gt;, not from the\nCrawlServer.\n     * The former is  spec=\r\nial in that if the &lt;code&gt;curi&lt;/curi&gt; credentials\n     * succeed, then the c=\r\naller needs to promote them from the\nCrawlURI to the\n     * CrawlServer so =\r\nthey are available for all subsequent CrawlURIs\non this\n     * server.\n    =\r\n */\n    private boolean populateCredentials(CrawlURI curi, HttpMethod\nmetho=\r\nd) {\n        // First look at the server avatars. Add any that are to be\nvo=\r\nlunteered\n        // on every request (e.g. RFC2617 credentials).  Every ti=\r\nme\ncreds will\n        // return true when we call &#39;isEveryTime().\n        C=\r\nrawlServer server =3D\n            getController().getServerCache().getServe=\r\nrFor(curi);\n        if (server.hasCredentialAvatars()) {\n            Set av=\r\natars =3D server.getCredentialAvatars();\n            for (Iterator i =3D av=\r\natars.iterator(); i.hasNext();) {\n                CredentialAvatar ca =3D (=\r\nCredentialAvatar)i.next();\n                Credential c =3D ca.getCredentia=\r\nl(getSettingsHandler(),\ncuri);\n                if (c.isEveryTime()) {\n     =\r\n               c.populate(curi, this.http, method, ca.getPayload());\n      =\r\n          }\n            }\n        }\n\n        boolean result =3D false;\n\n   =\r\n     // Now look in the curi.  The Curi will have credentials\nloaded either=\r\n\n        // by the handle401 method if its a rfc2617 or it&#39;ll have been\nset=\r\n into\n        // the curi by the preconditionenforcer as this login uri cam=\r\ne\nthrough.\n        if (curi.hasCredentialAvatars()) {\n            Set avata=\r\nrs =3D curi.getCredentialAvatars();\n            for (Iterator i =3D avatars=\r\n.iterator(); i.hasNext();) {\n                CredentialAvatar ca =3D (Crede=\r\nntialAvatar)i.next();\n                Credential c =3D ca.getCredential(get=\r\nSettingsHandler(),\ncuri);\n                if (c.populate(curi, this.http, m=\r\nethod,\nca.getPayload())) {\n                    result =3D true;\n           =\r\n     }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     =\r\n* Promote successful credential to the server.\n     *\n     * @param curi Cr=\r\nawlURI whose credentials we are to promote.\n     */\n    private void promot=\r\neCredentials(final CrawlURI curi) {\n        if (!curi.hasCredentialAvatars(=\r\n)) {\n            logger.severe(&quot;No credentials to promote when there should=\r\n\nbe &quot; +\n                curi);\n        } else {\n            Set avatars =3D=\r\n curi.getCredentialAvatars();\n            for (Iterator i =3D avatars.itera=\r\ntor(); i.hasNext();) {\n                CredentialAvatar ca =3D (CredentialA=\r\nvatar)i.next();\n                curi.removeCredentialAvatar(ca);\n          =\r\n      // The server to attach too may not be the server that\nhosts\n        =\r\n        // this passed curi.  It might be of another subdomain.\n           =\r\n     // The avatar needs to be added to the server that is\ndependent\n      =\r\n          // on this precondition.  Find it by name.  Get the\nname from\n   =\r\n             // the credential this avatar represents.\n                Cred=\r\nential c =3D ca.getCredential(getSettingsHandler(),\ncuri);\n                =\r\nString cd =3D null;\n                try {\n                    cd =3D c.getC=\r\nredentialDomain(curi);\n                }\n                catch (AttributeNo=\r\ntFoundException e) {\n                    logger.severe(&quot;Failed to get cred =\r\ndomain for &quot; +\ncuri +\n                        &quot; for &quot; + ca + &quot;: &quot; + e.getMe=\r\nssage());\n                }\n                if (cd !=3D null) {\n           =\r\n         CrawlServer cs\n                        =3D\ngetController().getServ=\r\nerCache().getServerFor(cd);\n                    if (cs !=3D null) {\n       =\r\n                 cs.addCredentialAvatar(ca);\n                    }\n        =\r\n        }\n            }\n        }\n    }\n\n    /**\n     * Server is looking f=\r\nor basic/digest auth credentials (RFC2617).\nIf we have\n     * any, put them=\r\n into the CrawlURI and have it come around again.\nPresence\n     * of the cr=\r\nedential serves as flag to frontier to requeue\npromptly. If we\n     * alrea=\r\ndy tried this domain and still got a 401, then our\ncredentials are\n     * b=\r\nad. Remove them and let this curi die.\n     *\n     * @param method Method t=\r\nhat got a 401.\n     * @param curi CrawlURI that got a 401.\n     */\n    prot=\r\nected void handle401(final HttpMethod method, final CrawlURI\ncuri) {\n      =\r\n  AuthScheme authscheme =3D getAuthScheme(method, curi);\n        if (authsc=\r\nheme =3D=3D null) {\n        \treturn;\n        }\n        String realm =3D aut=\r\nhscheme.getRealm();\n        \n        // Look to see if this curi had rfc261=\r\n7 avatars loaded.  If\nso, are\n        // any of them for this realm?  If so=\r\n, then the credential failed\n        // if we got a 401 and it should be le=\r\nt die a natural 401 death.\n        Set curiRfc2617Credentials =3D getCreden=\r\ntials(getSettingsHandler(),\n        \t\tcuri, Rfc2617Credential.class);\n     =\r\n   Rfc2617Credential extant =3D Rfc2617Credential.\n\t\t    getByRealm(curiRfc=\r\n2617Credentials, realm, curi);\n        if (extant !=3D null) {\n        \t// =\r\nThen, already tried this credential.  Remove ANY rfc2617\n        \t// creden=\r\ntial since presence of a rfc2617 credential serves\n        \t// as flag to f=\r\nrontier to requeue this curi and let the curi\n        \t// die a natural dea=\r\nth.\n        \textant.detachAll(curi);\n        \tlogger.warning(&quot;Auth failed (=\r\n401) though supplied realm &quot; +\n        \t\t\trealm + &quot; to &quot; + curi.toString())=\r\n;\n        } else {\n        \t// Look see if we have a credential that corres=\r\nponds to this\n        \t// realm in credential store.  Filter by type and cr=\r\nedential\n        \t// domain.  If not, let this curi die. Else, add it to th=\r\ne\n        \t// curi and let it come around again. Add in the AuthScheme\n    =\r\n    \t// we got too.  Its needed when we go to run the Auth on\n        \t// s=\r\necond time around.\n        \tCredentialStore cs =3D\n        \t\tCredentialStor=\r\ne.getCredentialStore(getSettingsHandler());\n        \tif (cs =3D=3D null) {\n=\r\n        \t\tlogger.severe(&quot;No credential store for &quot; + curi);\n        \t} else=\r\n {\n                CrawlServer server =3D getController().getServerCache().=\r\n\n                    getServerFor(curi);\n        \t\tSet storeRfc2617Credenti=\r\nals =3D cs.subset(curi,\n        \t\t    Rfc2617Credential.class, server.getNa=\r\nme());\n        \t\tif (storeRfc2617Credentials =3D=3D null ||\n        \t\t\t\tsto=\r\nreRfc2617Credentials.size() &lt;=3D 0) {\n        \t\t\tlogger.info(&quot;No rfc2617 cr=\r\nedentials for &quot; + curi);\n        \t\t} else {\n        \t\t\tRfc2617Credential fo=\r\nund =3D Rfc2617Credential.\n\t\t\t\t\t    getByRealm(storeRfc2617Credentials, rea=\r\nlm, curi);\n        \t\t\tif (found =3D=3D null) {\n        \t\t\t\tlogger.info(&quot;No =\r\nrfc2617 credentials for realm &quot; +\n        \t\t\t\t\t\trealm + &quot; in &quot; + curi);\n   =\r\n     \t\t\t} else {\n        \t\t\t\tfound.attach(curi, authscheme.getRealm());\n   =\r\n     \t\t\t\tlogger.info(&quot;Found credential for realm &quot; + realm +\n        \t\t\t\t  =\r\n  &quot; in store for &quot; + curi.toString());\n        \t\t\t}\n        \t\t}\n        \t}\n=\r\n        }\n    }\n    \n    /**\n     * @param method Method that got a 401.\n  =\r\n   * @param curi CrawlURI that got a 401.\n     * @return Returns first whol=\r\nesome authscheme found else null.\n     */\n    protected AuthScheme getAuthS=\r\ncheme(final HttpMethod method,\n            final CrawlURI curi) {\n        H=\r\neader [] headers =3D method.getResponseHeaders(&quot;WWW-Authenticate&quot;);\n       =\r\n if (headers =3D=3D null || headers.length &lt;=3D 0) {\n            logger.inf=\r\no(&quot;We got a 401 but no WWW-Authenticate\nchallenge: &quot; +\n                curi=\r\n.toString());\n            return null;\n        }\n\n        Map authschemes =\r\n=3D null;\n        try {\n            authschemes =3D AuthChallengeParser.par=\r\nseChallenges(headers);\n        } catch(MalformedChallengeException e) {\n   =\r\n         logger.info(&quot;Failed challenge parse: &quot; + e.getMessage());\n        =\r\n}\n        if (authschemes =3D=3D null || authschemes.size() &lt;=3D 0) {\n     =\r\n       logger.info(&quot;We got a 401 and WWW-Authenticate challenge&quot; +\n        =\r\n        &quot; but failed parse of the header &quot; + curi.toString());\n            =\r\nreturn null;\n        }            \n         \n        AuthScheme result =3D =\r\nnull;\n        // Use the first auth found.\n        for (Iterator i =3D auth=\r\nschemes.keySet().iterator();\n                result =3D=3D null && i.hasNex=\r\nt();) {\n        \tString key =3D (String)i.next();\n            String challe=\r\nnge =3D (String)authschemes.get(key);\n            if (key =3D=3D null || ke=\r\ny.length() &lt;=3D 0 || challenge =3D=3D null ||\n                  challenge.l=\r\nength() &lt;=3D 0) {\n            \tlogger.warning(&quot;Empty scheme: &quot; + curi.toStr=\r\ning() +\n                  &quot;: &quot; + headers);\n            }\n        \tAuthSchem=\r\ne authscheme =3D null;\n        \tif (key.equals(&quot;basic&quot;)) {\n        \t\tauthsc=\r\nheme =3D new BasicScheme();\n        \t} else if (key.equals(&quot;digest&quot;)) {\n   =\r\n     \t\tauthscheme =3D new DigestScheme();\n        \t} else {\n        \t\tlogge=\r\nr.info(&quot;Unsupported scheme: &quot; + key);\n        \t\tcontinue;\n        \t}\n      =\r\n      \n            try {\n\t\t\t\tauthscheme.processChallenge(challenge);\n\t\t\t} c=\r\natch (MalformedChallengeException e) {\n\t\t\t\tlogger.info(e.getMessage() + &quot; &quot;=\r\n + curi + &quot; &quot; + headers);\n                continue;\n\t\t\t}\n        \tif (auths=\r\ncheme.isConnectionBased()) {\n        \t\tlogger.info(&quot;Connection based &quot; + au=\r\nthscheme);\n        \t\tcontinue;\n        \t}\n        \t\n        \tif (authscheme=\r\n.getRealm() =3D=3D null ||\n        \t\t\tauthscheme.getRealm().length() &lt;=3D 0=\r\n) {\n        \t\tlogger.info(&quot;Empty realm &quot; + authscheme + &quot; for &quot; + curi);\n  =\r\n      \t\tcontinue;\n        \t}\n        \tresult =3D authscheme;\n        }\n    =\r\n    \n        return result;\n    }\n        \n    /**\n     * @param handler Se=\r\nttings Handler.\n     * @param curi CrawlURI that got a 401.\n     * @param t=\r\nype Class of credential to get from curi.\n     * @return Set of credentials=\r\n attached to this curi.\n     */\n    private Set getCredentials(SettingsHand=\r\nler handler, CrawlURI curi,\n            Class type) {\n        Set result =\r\n=3D null;\n\n        if (curi.hasCredentialAvatars()) {\n            for (Iter=\r\nator i =3D curi.getCredentialAvatars().iterator();\n                    i.ha=\r\nsNext();) {\n                CredentialAvatar ca =3D (CredentialAvatar)i.nex=\r\nt();\n                if (ca.match(type)) {\n                    if (result =\r\n=3D=3D null) {\n                        result =3D new HashSet();\n          =\r\n          }\n                    result.add(ca.getCredential(handler, curi))=\r\n;\n                }\n            }\n        }\n        return result;\n    }\n\n =\r\n   public void initialTasks() {\n        super.initialTasks();\n        this.=\r\ngetController().addCrawlStatusListener(this);\n        configureHttp();\n\n   =\r\n     // load cookies from a file if specified in the order file.\n        lo=\r\nadCookies();\n\n        // I tried to get the default KeyManagers but doesn&#39;t=\r\n work\nunless you\n        // point at a physical keystore. Passing null seem=\r\ns to do the\nright\n        // thing so we&#39;ll go w/ that.\n        try {\n     =\r\n   \tSSLContext context =3D SSLContext.getInstance(&quot;SSL&quot;);\n\t\t\tcontext.init(n=\r\null, new TrustManager[] {\n\t\t\t    new ConfigurableX509TrustManager((String)\n=\r\n\t\t\t        getAttribute(ATTR_TRUST))}, null);\n\t        this.sslfactory =3D =\r\ncontext.getSocketFactory();\n\t\t} catch (Exception e) {\n\t\t\tlogger.log(Level.W=\r\nARNING, &quot;Failed configure of ssl context &quot;\n\t\t\t    + e.getMessage(), e);\n\t\t}=\r\n\n    }\n    \n    public void finalTasks() {\n        // At the end save cooki=\r\nes to the file specified in the order\nfile.\n        saveCookies();\n        =\r\ncleanupHttp();\n        super.finalTasks();\n    }\n\n    /**\n     * Perform an=\r\ny final cleanup related to the HttpClient instance.\n     */\n    protected v=\r\noid cleanupHttp() {\n        if(cookieDb!=3Dnull) {\n            try {\n      =\r\n          cookieDb.close();\n            } catch (DatabaseException e) {\n   =\r\n             // TODO Auto-generated catch block\n                e.printStac=\r\nkTrace();\n            }\n        }\n    }\n\n    protected void configureHttp()=\r\n throws RuntimeException {\n        // Get timeout.  Use it for socket and f=\r\nor connection timeout.\n        int timeout =3D (getSoTimeout(null) &gt; 0)? ge=\r\ntSoTimeout(null): 0;\n        \n        // HttpConnectionManager cm =3D new\nT=\r\nhreadLocalHttpConnectionManager();\n        HttpConnectionManager cm =3D new=\r\n SingleHttpConnectionManager();\n        \n        // TODO: The following set=\r\ntings should be made in the\ncorresponding\n        // HttpConnectionManager,=\r\n not here.\n        HttpConnectionManagerParams hcmp =3D cm.getParams();\n   =\r\n     hcmp.setConnectionTimeout(timeout);\n        hcmp.setStaleCheckingEnabl=\r\ned(true);\n        // Minimizes bandwidth usage.  Setting to true disables N=\r\nagle&#39;s\n        // algorithm.  IBM JVMs &lt; 142 give an NPE setting this boole=\r\nan\n        // on ssl sockets.\n        hcmp.setTcpNoDelay(false);\n        /*=\r\n\n         * String url =3D &quot;http://mysite.com/index.html&quot;; \n    HttpClient =\r\nclient =3D new HttpClient();\n    HttpMethod method =3D new GetMethod(url);\n=\r\n    HostConfiguration hostConfig=3D client.getHostConfiguration();\n    // U=\r\npdate this to point to NTLM enabled proxy\n    hostConfig.setProxy(&quot;192.168.=\r\n0.0&quot;, 80); \n\n    // Authenticate using NTLM\n    client.getState().setProxyC=\r\nredentials(AuthScope.ANY,\n          new NTCredentials(&quot;userid&quot;,&quot;password&quot;,&quot;=\r\n&quot;,&quot;&quot;));\n\n    int statusCode =3D client.executeMethod(method);\n    System.ou=\r\nt.println(&quot;Stat=3D&quot; +HttpStatus.getStatusText(statusCode));\n    String strO=\r\nutput =3D method.getResponseBodyAsString();\n     */\n        this.http =3D n=\r\new HttpClient(cm);\n        \n        HttpClientParams hcp =3D this.http.getP=\r\narams();\n        // Set default socket timeout.\n        hcp.setSoTimeout(ti=\r\nmeout);\n        // Set client to be version 1.0.\n        hcp.setVersion(Htt=\r\npVersion.HTTP_1_0);\n\n\t\tString addressStr =3D null;\n\t\ttry {\n\t\t\taddressStr =\r\n=3D (String) getAttribute(ATTR_LOCAL_ADDRESS);\n\t\t} catch (Exception e1) {\n\t=\r\n\t\t// If exception, just use default.\n\t\t}\n\t\tif (addressStr !=3D null && addr=\r\nessStr.length() &gt; 0) {\n\t\t\ttry {\n\t\t\t\tInetAddress localAddress =3D InetAddres=\r\ns.getByName(addressStr);\n\t\t\t\tthis.http.getHostConfiguration().setLocalAddre=\r\nss(localAddress);\n\t\t\t} catch (UnknownHostException e) {\n\t\t\t\t// Convert all =\r\nto RuntimeException so get an exception out\n\t\t\t\t// if initialization fails.=\r\n\n\t\t\t\tthrow new RuntimeException(&quot;Unknown host &quot; + addressStr\n\t\t\t\t    + &quot; in=\r\n &quot; + ATTR_LOCAL_ADDRESS);\n\t\t\t}\n\t\t}\n\n\t\tconfigureHttpCookies();\n        \n    =\r\n    // Configure how we want the method to act.\n        this.http.getParams=\r\n().setParameter(\n            HttpMethodParams.SINGLE_COOKIE_HEADER, new Boo=\r\nlean(true));\n        this.http.getParams().setParameter(\n            HttpMe=\r\nthodParams.UNAMBIGUOUS_STATUS_LINE , new\nBoolean(false));\n        this.http=\r\n.getParams().setParameter(\n            HttpMethodParams.STRICT_TRANSFER_ENC=\r\nODING, new\nBoolean(false));\n        this.http.getParams().setIntParameter(\n=\r\n            HttpMethodParams.STATUS_LINE_GARBAGE_LIMIT, 10);\n        \n     =\r\n   HostConfiguration configOrNull =3D configureProxy(null);\n  \n        if(c=\r\nonfigOrNull!=3Dnull) {\n            // global proxy settings are in effect\n =\r\n           this.http.setHostConfiguration(configOrNull);\n        }\n        =\r\n\n        // Use our own protocol factory, one that gets IP to use from\n    =\r\n    // heritrix cache (They&#39;re cached in CrawlHost instances).\n        fina=\r\nl ServerCache cache =3D getController().getServerCache();\n        hcmp.setP=\r\narameter(SERVER_CACHE_KEY, cache);\n        hcmp.setParameter(SSL_FACTORY_KE=\r\nY, this.sslfactory);\n\t}\n\n    /**\n     * Set the HttpClient HttpState instan=\r\nce to use a BDB-backed\n     * StoredSortedMap for cookie storage, if that o=\r\nption is chosen.\n     */\n    private void configureHttpCookies() {\n        =\r\n// If Bdb-backed cookies chosen, replace map in HttpState\n        if(((Bool=\r\nean)getUncheckedAttribute(null, ATTR_BDB_COOKIES)).\n                boolean=\r\nValue()) {\n            try {\n                Environment env =3D getControl=\r\nler().getBdbEnvironment();\n                StoredClassCatalog classCatalog =\r\n=3D\ngetController().getClassCatalog();\n                DatabaseConfig dbCon=\r\nfig =3D new DatabaseConfig();\n                dbConfig.setTransactional(fal=\r\nse);\n                dbConfig.setAllowCreate(true);\n                cookieD=\r\nb =3D env.openDatabase(null, COOKIEDB_NAME,\ndbConfig);\n                Stor=\r\nedSortedMap cookiesMap =3D new StoredSortedMap(cookieDb,\n                  =\r\n      new StringBinding(), new\nSerialBinding(classCatalog,\n                =\r\n                Cookie.class), true);\n                this.http.getState().=\r\nsetCookiesMap(cookiesMap);\n            } catch (DatabaseException e) {\n    =\r\n            // TODO Auto-generated catch block\n                logger.sever=\r\ne(e.getMessage());\n                e.printStackTrace();\n            }\n     =\r\n   }\n    }\n\n    /**\n     * @param curi Current CrawlURI.  Used to get conte=\r\nxt.\n     * @return Socket timeout value.\n     */\n    private int getSoTimeo=\r\nut(CrawlURI curi) {\n        Integer res =3D null;\n        try {\n           =\r\n res =3D (Integer) getAttribute(ATTR_SOTIMEOUT_MS, curi);\n        } catch (=\r\nException e) {\n            res =3D DEFAULT_SOTIMEOUT_MS;\n        }\n        =\r\nreturn res.intValue();\n    }\n\n    /**\n     * @param curi Current CrawlURI. =\r\n Used to get context.\n     * @return Timeout value for total request.\n     =\r\n*/\n    private int getTimeout(CrawlURI curi) {\n        Integer res;\n       =\r\n try {\n            res =3D (Integer) getAttribute(ATTR_TIMEOUT_SECONDS, cur=\r\ni);\n        } catch (Exception e) {\n            res =3D DEFAULT_TIMEOUT_SEC=\r\nONDS;\n        }\n        return res.intValue();\n    }\n\n    private int getMa=\r\nxFetchRate(CrawlURI curi) {\n        Integer res;\n        try {\n            =\r\nres =3D (Integer)getAttribute(ATTR_FETCH_BANDWIDTH_MAX, curi);\n        }\n  =\r\n      catch (Exception e) {\n            res =3D DEFAULT_FETCH_BANDWIDTH_MAX=\r\n;\n        }\n        return res.intValue();\n    }\n\n    private long getMaxLe=\r\nngth(CrawlURI curi) {\n        Long res;\n        try {\n            res =3D (=\r\nLong) getAttribute(ATTR_MAX_LENGTH_BYTES, curi);\n            if (res.longVa=\r\nlue() =3D=3D OLD_DEFAULT_MAX_LENGTH_BYTES) {\n                res =3D DEFAUL=\r\nT_MAX_LENGTH_BYTES;\n            }\n        } catch (Exception e) {\n         =\r\n   res =3D DEFAULT_MAX_LENGTH_BYTES;\n        }\n        return res.longValue=\r\n();\n    }\n\n    /**\n     * Load cookies from a file before the first fetch.\n=\r\n     * &lt;p&gt;\n     * The file is a text file in the Netscape&#39;s &#39;cookies.txt&#39; f=\r\nile\nformat.&lt;br&gt;\n     * Example entry of cookies.txt file:&lt;br&gt;\n     * &lt;br&gt;\n =\r\n    * www.archive.org FALSE / FALSE 1074567117 details-visit\ntexts-cralond&lt;=\r\nbr&gt;\n     * &lt;br&gt;\n     * Each line has 7 tab-separated fields:&lt;br&gt;\n     * &lt;li=\r\n&gt;1. DOMAIN: The domain that created and have access to the\ncookie\n     * va=\r\nlue.\n     * &lt;li&gt;2. FLAG: A TRUE or FALSE value indicating if hosts within\nt=\r\nhe given\n     * domain can access the cookie value.\n     * &lt;li&gt;3. PATH: The=\r\n path within the domain that the cookie value\nis valid\n     * for.\n     * &lt;=\r\nli&gt;4. SECURE: A TRUE or FALSE value indicating if to use a secure\n     * co=\r\nnnection to access the cookie value.\n     * &lt;li&gt;5. EXPIRATION: The expirati=\r\non time of the cookie value\n(unix style.)\n     * &lt;li&gt;6. NAME: The name of t=\r\nhe cookie value\n     * &lt;li&gt;7. VALUE: The cookie value\n     *\n     * @param =\r\ncookiesFile file in the Netscape&#39;s &#39;cookies.txt&#39; format.\n     */\n    public=\r\n void loadCookies(String cookiesFile) {\n        // Do nothing if cookiesFil=\r\ne is not specified.\n        if (cookiesFile =3D=3D null || cookiesFile.leng=\r\nth() &lt;=3D 0) {\n            return;\n        }\n        RandomAccessFile raf =\r\n=3D null;\n        try {\n            raf =3D new RandomAccessFile(cookiesFil=\r\ne, &quot;r&quot;);\n            String[] cookieParts;\n            String line;\n       =\r\n     Cookie cookie =3D null;\n            while ((line =3D raf.readLine()) !=\r\n=3D null) {\n                // Line that starts with # is commented line,\nt=\r\nherefore skip it.\n                if (!line.startsWith(&quot;#&quot;)) {\n            =\r\n        cookieParts =3D line.split(&quot;&#92;&#92;t&quot;);\n                    if (cookiePa=\r\nrts.length =3D=3D 7) {\n                        // Create cookie with not ex=\r\npiration date (-1\nvalue).\n                        // TODO: add this as an o=\r\nption.\n                        cookie =3D\n                            new C=\r\nookie(cookieParts[0], cookieParts[5],\n                                cooki=\r\neParts[6], cookieParts[2], -1,\n                               \nBoolean.valu=\r\neOf(cookieParts[3]).booleanValue());\n\n                        if (cookiePar=\r\nts[1].toLowerCase().equals(&quot;true&quot;)) {\n                            cookie.se=\r\ntDomainAttributeSpecified(true);\n                        } else {\n         =\r\n                   cookie.setDomainAttributeSpecified(false);\n             =\r\n           }\n                        this.http.getState().addCookie(cookie)=\r\n;\n                        logger.fine(\n                            &quot;Adding =\r\ncookie: &quot; + cookie.toExternalForm());\n                    }\n               =\r\n }\n            }\n        } catch (FileNotFoundException e) {\n            //=\r\n We should probably throw FatalConfigurationException.\n            System.o=\r\nut.println(&quot;Could not find file: &quot; + cookiesFile\n                    + &quot; (E=\r\nlement: &quot; + ATTR_LOAD_COOKIES + &quot;)&quot;);\n\n        } catch (IOException e) {\n  =\r\n          // We should probably throw FatalConfigurationException.\n        =\r\n    e.printStackTrace();\n        } finally {\n            try {\n            =\r\n    if (raf !=3D null) {\n                    raf.close();\n                }=\r\n\n            } catch (IOException e) {\n                e.printStackTrace();=\r\n\n            }\n        }\n    }\n\n    /* (non-Javadoc)\n     * @see org.archiv=\r\ne.crawler.framework.Processor#report()\n     */\n    public String report() {=\r\n\n        StringBuffer ret =3D new StringBuffer();\n        ret.append(&quot;Proce=\r\nssor: org.archive.crawler.fetcher.FetchHTTP&#92;n&quot;);\n        ret.append(&quot;  Func=\r\ntion:          Fetch HTTP URIs&#92;n&quot;);\n        ret.append(&quot;  CrawlURIs handled=\r\n: &quot; + this.curisHandled + &quot;&#92;n&quot;);\n        ret.append(&quot;  Recovery retries:   =\r\n&quot; + this.recoveryRetries +\n&quot;&#92;n&#92;n&quot;);\n\n        return ret.toString();\n    }\n\n=\r\n\n    /**\n     * Load cookies from the file specified in the order file.\n   =\r\n  *\n     * &lt;p&gt;\n     * The file is a text file in the Netscape&#39;s &#39;cookies.tx=\r\nt&#39; file\nformat.&lt;br&gt;\n     * Example entry of cookies.txt file:&lt;br&gt;\n     * &lt;b=\r\nr&gt;\n     * www.archive.org FALSE / FALSE 1074567117 details-visit\ntexts-cral=\r\nond&lt;br&gt;\n     * &lt;br&gt;\n     * Each line has 7 tab-separated fields:&lt;br&gt;\n     *=\r\n &lt;li&gt;1. DOMAIN: The domain that created and have access to the\ncookie\n     =\r\n* value.\n     * &lt;li&gt;2. FLAG: A TRUE or FALSE value indicating if hosts with=\r\nin\nthe given\n     * domain can access the cookie value.\n     * &lt;li&gt;3. PATH:=\r\n The path within the domain that the cookie value\nis valid\n     * for.\n    =\r\n * &lt;li&gt;4. SECURE: A TRUE or FALSE value indicating if to use a secure\n     =\r\n* connection to access the cookie value.\n     * &lt;li&gt;5. EXPIRATION: The expi=\r\nration time of the cookie value\n(unix style.)\n     * &lt;li&gt;6. NAME: The name =\r\nof the cookie value\n     * &lt;li&gt;7. VALUE: The cookie value\n     */\n    publi=\r\nc void loadCookies() {\n        try {\n            loadCookies((String) getAt=\r\ntribute(ATTR_LOAD_COOKIES));\n        } catch (MBeanException e) {\n         =\r\n   logger.warning(e.getLocalizedMessage());\n        } catch (ReflectionExce=\r\nption e) {\n            logger.warning(e.getLocalizedMessage());\n        } c=\r\natch (AttributeNotFoundException e) {\n            logger.warning(e.getLocal=\r\nizedMessage());\n        }\n    }\n    /**\n     * Saves cookies to the file sp=\r\necified in the order file.\n     *\n     * Output file is in the Netscape &#39;co=\r\nokies.txt&#39; format.\n     *\n     */\n    public void saveCookies() {\n        t=\r\nry {\n            saveCookies((String) getAttribute(ATTR_SAVE_COOKIES));\n   =\r\n     } catch (MBeanException e) {\n            logger.warning(e.getLocalized=\r\nMessage());\n        } catch (ReflectionException e) {\n            logger.wa=\r\nrning(e.getLocalizedMessage());\n        } catch (AttributeNotFoundException=\r\n e) {\n            logger.warning(e.getLocalizedMessage());\n        }\n    }\n=\r\n    /**\n     * Saves cookies to a file.\n     *\n     * Output file is in the=\r\n Netscape &#39;cookies.txt&#39; format.\n     *\n     * @param saveCookiesFile output=\r\n file.\n     */\n    public void saveCookies(String saveCookiesFile) {\n      =\r\n  // Do nothing if cookiesFile is not specified.\n        if (saveCookiesFil=\r\ne =3D=3D null || saveCookiesFile.length() &lt;=3D 0) {\n            return;\n   =\r\n     }\n\n        FileOutputStream out =3D null;\n        try {\n            ou=\r\nt =3D new FileOutputStream(new File(saveCookiesFile));\n            Cookie c=\r\nookies[] =3D this.http.getState().getCookies();\n            String tab =3D&quot;=\r\n&#92;t&quot;;\n            out.write(&quot;# Heritrix Cookie File&#92;n&quot;.getBytes());\n        =\r\n    out.write(\n                &quot;# This file is the Netscape cookies.txt\nfor=\r\nmat&#92;n&#92;n&quot;.getBytes());\n            for (int i =3D 0; i &lt; cookies.length; i++=\r\n) {\n                MutableString line =3D\n                    new MutableS=\r\ntring(1024 * 2 /*Guess an initial size*/);\n                line.append(cook=\r\nies[i].getDomain());\n                line.append(tab);\n                line=\r\n.append(\n                    cookies[i].isDomainAttributeSpecified() =3D=3D=\r\n true\n                        ? &quot;TRUE&quot;\n                        : &quot;FALSE&quot;);\n=\r\n                line.append(tab);\n                line.append(cookies[i].ge=\r\ntPath());\n                line.append(tab);\n                line.append(\n  =\r\n                  cookies[i].getSecure() =3D=3D true ? &quot;TRUE&quot; : &quot;FALSE&quot;);\n =\r\n               line.append(tab);\n                line.append(cookies[i].get=\r\nName());\n                line.append(tab);\n                line.append(cook=\r\nies[i].getValue());\n                line.append(&quot;&#92;n&quot;);\n                out.=\r\nwrite(line.toString().getBytes());\n            }\n        } catch (FileNotFo=\r\nundException e) {\n            // We should probably throw FatalConfiguratio=\r\nnException.\n            System.out.println(&quot;Could not find file: &quot; + saveCo=\r\nokiesFile\n                    + &quot; (Element: &quot; + ATTR_SAVE_COOKIES + &quot;)&quot;);\n =\r\n       } catch (IOException e) {\n            e.printStackTrace();\n        }=\r\n finally {\n            try {\n                if (out !=3D null) {\n         =\r\n           out.close();\n                }\n            } catch (IOException =\r\ne) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n  =\r\n  /* (non-Javadoc)\n     * @see\norg.archive.crawler.settings.ModuleType#list=\r\nUsedFiles(java.util.List)\n     */\n    protected void listUsedFiles(List lis=\r\nt) {\n        // List the cookies files\n        // Add seed file\n        try=\r\n {\n            String tmp =3D (String)getAttribute(ATTR_LOAD_COOKIES);\n    =\r\n        if(tmp !=3D null && tmp.length() &gt; 0){\n                File file =\r\n=3D getSettingsHandler().\n                        getPathRelativeToWorkingD=\r\nirectory(tmp);\n                list.add(file.getAbsolutePath());\n          =\r\n  }\n            tmp =3D (String)getAttribute(ATTR_SAVE_COOKIES);\n          =\r\n  if(tmp !=3D null && tmp.length() &gt; 0){\n                File file =3D getS=\r\nettingsHandler().\n                        getPathRelativeToWorkingDirectory=\r\n(tmp);\n                list.add(file.getAbsolutePath());\n            }\n    =\r\n    } catch (AttributeNotFoundException e) {\n \n(Message over 64 KB, truncated)"}}