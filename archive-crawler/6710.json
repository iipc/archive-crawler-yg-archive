{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":452268320,"authorName":"eimhee","from":"&quot;eimhee&quot; &lt;eimhee@...&gt;","profile":"eimhee","replyTo":"LIST","senderId":"KZqT8cRBO8c1zuH1PqG7-Xt3_6QBP0r8Zbc9GznznexA7ZR5bzsg5_fm6cUT39O4lojrg6-8aj5L1T8fES8DoKAYGZ7D","spamInfo":{"isSpam":false,"reason":"0"},"subject":"study the heritrix3 source code","postDate":"1283417970","msgId":6710,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PGk1bnAxaStxNm1yQGVHcm91cHMuY29tPg=="},"prevInTopic":0,"nextInTopic":0,"prevInTime":6709,"nextInTime":6711,"topicId":6710,"numMessagesInTopic":1,"msgSnippet":"Recent I study the heritrix3 source code, I found it very complex to understand some source code, for example WorkQueueFrontier. Is there any material for it? ","rawEmail":"Return-Path: &lt;eimhee@...&gt;\r\nX-Sender: eimhee@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nX-Received: (qmail 10706 invoked from network); 2 Sep 2010 08:59:32 -0000\r\nX-Received: from unknown (66.196.94.106)\n  by m12.grp.re1.yahoo.com with QMQP; 2 Sep 2010 08:59:32 -0000\r\nX-Received: from unknown (HELO n41b.bullet.mail.sp1.yahoo.com) (66.163.168.155)\n  by mta2.grp.re1.yahoo.com with SMTP; 2 Sep 2010 08:59:31 -0000\r\nX-Received: from [69.147.65.174] by n41.bullet.mail.sp1.yahoo.com with NNFMP; 02 Sep 2010 08:59:31 -0000\r\nX-Received: from [98.137.35.12] by t12.bullet.mail.sp1.yahoo.com with NNFMP; 02 Sep 2010 08:59:31 -0000\r\nDate: Thu, 02 Sep 2010 08:59:30 -0000\r\nTo: archive-crawler@yahoogroups.com\r\nMessage-ID: &lt;i5np1i+q6mr@...&gt;\r\nUser-Agent: eGroups-EW/0.82\r\nMIME-Version: 1.0\r\nContent-Type: text/plain; charset=&quot;ISO-8859-1&quot;\r\nContent-Transfer-Encoding: quoted-printable\r\nX-Mailer: Yahoo Groups Message Poster\r\nX-Yahoo-Newman-Property: groups-compose\r\nFrom: &quot;eimhee&quot; &lt;eimhee@...&gt;\r\nSubject: study the heritrix3 source code\r\nX-Yahoo-Group-Post: member; u=452268320; y=EnOyFMaVHTgMJbhL5htKDo88P_VbuJXjVlxK1w63aJJH\r\nX-Yahoo-Profile: eimhee\r\n\r\n  Recent I study the heritrix3 source code, I found it very complex to unde=\r\nrstand some source code, for example WorkQueueFrontier.\nIs there any materi=\r\nal for it?\n\n\n\n\n  /**\n     * Return the next CrawlURI eligible to be process=\r\ned (and presumably\n     * visited/fetched) by a a worker thread.\n     *\n   =\r\n  * Relies on the readyClassQueues having been loaded with\n     * any work =\r\nqueues that are eligible to provide a URI. \n     *\n     * @return next Craw=\r\nlURI eligible to be processed, or null if none available\n     *\n     * @see=\r\n org.archive.crawler.framework.Frontier#next()\n     */\n    protected CrawlU=\r\nRI findEligibleURI() {\n            assert Thread.currentThread() =3D=3D man=\r\nagerThread;\n            // wake any snoozed queues\n            wakeQueues()=\r\n;\n            // consider rescheduled URIS\n            checkFutures();\n    =\r\n        // activate enough inactive queues to fill outbound\n            int=\r\n activationsWanted =3D \n                outbound.remainingCapacity() - read=\r\nyClassQueues.size();\n            while(activationsWanted &gt; 0 \n             =\r\n       && !getInactiveQueuesByPrecedence().isEmpty() \n                    &=\r\n& highestPrecedenceWaiting &lt; getPrecedenceFloor()) {\n                activa=\r\nteInactiveQueue();\n                activationsWanted--;\n            }\n     =\r\n              \n            // find a non-empty ready queue, if any \n       =\r\n     // TODO: refactor to untangle these loops, early-exits, etc!\n         =\r\n   WorkQueue readyQ =3D null;\n            findauri: while(true) {\n         =\r\n       findaqueue: do {\n                    String key =3D readyClassQueues=\r\n.poll();\n                    if(key=3D=3D null) {\n                        /=\r\n/ no ready queues\n                        break;\n                    }\n    =\r\n                readyQ =3D getQueueFor(key);\n                    if(readyQ=\r\n=3D=3Dnull) {\n                         // readyQ key wasn&#39;t in all queues: =\r\nunexpected\n                        logger.severe(&quot;Key &quot;+ key +\n            =\r\n                &quot; in readyClassQueues but not allQueues&quot;);\n                =\r\n        break findaqueue;\n                    }\n                    if(read=\r\nyQ.getCount()=3D=3D0) {\n                        // readyQ is empty and read=\r\ny: it&#39;s exhausted\n                        // release held status, allowing =\r\nany subsequent \n                        // enqueues to again put queue in r=\r\neady\n                        readyQ.clearHeld();\n                        re=\r\nadyQ =3D null;\n                    }\n                } while (readyQ =3D=3D=\r\n null);\n                \n                if (readyQ =3D=3D null) {\n        =\r\n            break findauri; \n                }\n               \n            =\r\n    assert !inProcessQueues.contains(readyQ) : &quot;double activation&quot;;\n       =\r\n         returnauri: while(true) { // loop left by explicit return or break=\r\n on empty\n                    CrawlURI curi =3D null;\n                    c=\r\nuri =3D readyQ.peek(this);   \n                    if(curi =3D=3D null) {\n  =\r\n                      // should not reach\n                        logger.se=\r\nvere(&quot;No CrawlURI from ready non-empty queue &quot;\n                            =\r\n    + readyQ.classKey + &quot;&#92;n&quot; \n                                + readyQ.sing=\r\nleLineLegend() + &quot;&#92;n&quot;\n                                + readyQ.singleLineRe=\r\nport() + &quot;&#92;n&quot;);\n                        break returnauri;\n                 =\r\n   }\n                    \n                    // from queues, override name=\r\ns persist but not map source\n                    curi.setOverlayMapsSource(=\r\nsheetOverlaysManager);\n                    // check if curi belongs in diff=\r\nerent queue\n                    String currentQueueKey;\n                   =\r\n try {\n                        KeyedProperties.loadOverridesFrom(curi);\n   =\r\n                     currentQueueKey =3D getClassKey(curi);\n               =\r\n     } finally {\n                        KeyedProperties.clearOverridesFrom=\r\n(curi); \n                    }\n                    if (currentQueueKey.equa=\r\nls(curi.getClassKey())) {\n                        // curi was in right queu=\r\ne, emit\n                        noteAboutToEmit(curi, readyQ);\n            =\r\n            inProcessQueues.add(readyQ);\n                        return cur=\r\ni;\n                    }\n                    // URI&#39;s assigned queue has ch=\r\nanged since it\n                    // was queued (eg because its IP has bec=\r\nome\n                    // known). Requeue to new queue.\n                  =\r\n  readyQ.dequeue(this,curi);\n                    doJournalRelocated(curi);\n=\r\n                    curi.setClassKey(currentQueueKey);\n                    =\r\ndecrementQueuedCount(1);\n                    curi.setHolderKey(null);\n     =\r\n               sendToQueue(curi);\n                    if(readyQ.getCount()=\r\n=3D=3D0) {\n                        // readyQ is empty and ready: it&#39;s exhau=\r\nsted\n                        // release held status, allowing any subsequen=\r\nt \n                        // enqueues to again put queue in ready\n        =\r\n                readyQ.clearHeld();\n                        readyQ =3D null=\r\n;\n                        continue findauri;\n                    }\n        =\r\n        }\n            }\n                \n            if(inProcessQueues.siz=\r\ne()=3D=3D0) {\n                // Nothing was ready or in progress or immine=\r\nnt to wake; ensure \n                // any piled-up pending-scheduled URIs =\r\nare considered\n                uriUniqFilter.requestFlush();\n            }\n=\r\n            \n            // never return null if there are any eligible ina=\r\nctives\n            if(getTotalEligibleInactiveQueues()&gt;0) {\n               =\r\n return findEligibleURI();\n            }\n            \n            // nothin=\r\ng eligible\n            return null; \n    }\n\n\n"}}