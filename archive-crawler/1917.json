{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":137285340,"authorName":"Gordon Mohr","from":"Gordon Mohr &lt;gojomo@...&gt;","profile":"gojomo","replyTo":"LIST","senderId":"VNWeqBUVW45Stf13sVnvS_xyRmNoo9H_gJUGcAviHTzG8qhuYheNrpzzfdr7GaApuwNKC0gCmUZYf5LJN3IS4Xpyt_s0nrE","spamInfo":{"isSpam":false,"reason":"12"},"subject":"Re: [archive-crawler] Re: TextUtils getMatcher ThreadLocal-ized","postDate":"1118108114","msgId":1917,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQyQTRGOUQyLjgwNTA4MDFAYXJjaGl2ZS5vcmc+","inReplyToHeader":"PDIwMDUwNjAzMTEzMy4yMjQwNi5jay1oZXJpdHJpeEBuZXdzY2x1Yi5kZT4=","referencesHeader":"PEUxRGRYY1YtMDAwNHNFLTdPQHNjOC1wci1jdnMxLnNvdXJjZWZvcmdlLm5ldD4gPDQyOUY1QTVELjMwODAyMDNAYXJjaGl2ZS5vcmc+IDwyMDA1MDYwMzExMzMuMjI0MDYuY2staGVyaXRyaXhAbmV3c2NsdWIuZGU+"},"prevInTopic":1906,"nextInTopic":1919,"prevInTime":1916,"nextInTime":1918,"topicId":1906,"numMessagesInTopic":5,"msgSnippet":"Hi, Christian. Good ideas, but with your suggested tactic, code that isn t careful could still have unpredictable results. Perhaps this is a contrived example,","rawEmail":"Return-Path: &lt;gojomo@...&gt;\r\nX-Sender: gojomo@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 94723 invoked from network); 7 Jun 2005 01:35:22 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m30.grp.scd.yahoo.com with QMQP; 7 Jun 2005 01:35:22 -0000\r\nReceived: from unknown (HELO ia00524.archive.org) (207.241.224.172)\n  by mta2.grp.scd.yahoo.com with SMTP; 7 Jun 2005 01:35:22 -0000\r\nReceived: (qmail 17344 invoked by uid 100); 7 Jun 2005 01:35:14 -0000\r\nReceived: from b116-dyn-239.archive.org (HELO ?207.241.238.239?) (gojomo@...@207.241.238.239)\n  by mail-dev.archive.org with SMTP; 7 Jun 2005 01:35:14 -0000\r\nMessage-ID: &lt;42A4F9D2.8050801@...&gt;\r\nDate: Mon, 06 Jun 2005 18:35:14 -0700\r\nUser-Agent: Mozilla Thunderbird 1.0.2-1.3.2 (X11/20050324)\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: archive-crawler@yahoogroups.com\r\nReferences: &lt;E1DdXcV-0004sE-7O@...&gt; &lt;429F5A5D.3080203@...&gt; &lt;200506031133.22406.ck-heritrix@...&gt;\r\nIn-Reply-To: &lt;200506031133.22406.ck-heritrix@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Spam-DCC: : \r\nX-Spam-Checker-Version: SpamAssassin 2.63 (2004-01-11) on ia00524.archive.org\r\nX-Spam-Level: \r\nX-Spam-Status: No, hits=-65.6 required=7.0 tests=AWL,RISK_FREE,\n\tUSER_IN_WHITELIST autolearn=no version=2.63\r\nX-eGroups-Msg-Info: 1:12:0\r\nFrom: Gordon Mohr &lt;gojomo@...&gt;\r\nSubject: Re: [archive-crawler] Re: TextUtils getMatcher ThreadLocal-ized\r\nX-Yahoo-Group-Post: member; u=137285340; y=y9KNksDjpLztsW_Q4skUuFJ7qekQNy09O7D9araTfDs5\r\nX-Yahoo-Profile: gojomo\r\n\r\nHi, Christian.\n\nGood ideas, but with your suggested tactic, code that isn&#39;t careful\ncould still have unpredictable results.\n\nPerhaps this is a contrived example, but consider the following\nmethod:\n\nboolean correlateMatches(String s1, String s2) {\n     // see if all matches-of-interest within the two strings\n     // correlate, ignoring intervening material\n     Matcher m1 = TextUtils.getMatcher(PATTERN_OF_INTEREST,s1);\n     Matcher m2 = TextUtils.getMatcher(PATTERN_OF_INTEREST,s2);\n     while(m1.find()) {\n         if(m2.find() && m1.group().equals(m2.group())) {\n             continue;\n         } else {\n             return false; // mismatch between strings\n         }\n     }\n     return true;\n}\n\nIf both getMatcher()s return the same instance because an\nobject-identical key was passed in, this method doesn&#39;t work.\n(The same could be the case for other methods sharing the same\npool of reference Pattern instances.)\n\nOf course, this can be prevented by declaring such usage against\nthe contract of getMatcher(), and saying such use is the caller&#39;s\nfault... but this could lead to subtle bugs, and it&#39;d be nice if\ngetMatcher() was no more dangerous to use than creating your\nown Matcher instance.\n\nYour point about constantly growing and shrinking the Map (with\nattendant instance creation) is well-taken. I think this can be\naddressed by put()ting a &#39;null&#39; in rather than remove()ing the\nkey when a Matcher is taken, then also put()ting the matcher\nback if/when freeMatcher() is used.\n\nThe HashMap.put() implementation reuses the existing Entry\ninstance, so no new allocation or change in the Map buckets\nwill occur when nulling (or reinserting) a previous mapping.\n\nWhat do you think?\n\n- Gordon @ IA\n\n\nChristian Kohlschuetter wrote:\n&gt; The whole idea of having TextUtils.getMatcher() was to avoid Matcher \n&gt; instantiation, so we are basically talking about cache efficiency and \n&gt; performance.\n&gt; \n&gt; You are right that the getMatcher()/freeMatcher() idiom definitely is &quot;safe&quot; \n&gt; to use and easy to understand. However, I fear that constantly removing and \n&gt; re-adding Matchers from the Map re-introduces an unjustified management \n&gt; overhead inside the Map implementation, decreasing the efficiency of the \n&gt; cache.\n&gt; \n&gt; In the current situation, the cache map grows until all Matchers have been \n&gt; used once (this should happen after having crawled the first few documents), \n&gt; and then remains read-only, whereas your scenario implicates that the Map \n&gt; grows and shrinks steadily.\n&gt; \n&gt; The problem basically is that is one cannot guarantee that any outer code does \n&gt; not make use of the same patterns. In that case, there is a (potential) \n&gt; chance that the outer Matcher would be corrupted, especially if the caller is \n&gt; another class which is not under your control (the patterns currently are \n&gt; defined as static String constants, thus being intern()&#39;ed automatically)\n&gt; \n&gt; We can solve that dilemma if the patterns were not interned, ie. \n&gt; disambiguated. We could simply append a unique comment string to the pattern \n&gt; (like the caller&#39;s class name), or wrap the pattern string by another Object \n&gt; which is inserted into the Map instead of the String).\n&gt; \n&gt; My favourite solution is the latter one, as it is already supported by the \n&gt; Java API (using the Pattern class). Instead of Strings, we should directly \n&gt; assign Patterns to the static fields of the calling class, like:\n&gt; private final Pattern DIGITS = Pattern.compile(&quot;[0-9]+&quot;);\n&gt; instead of\n&gt; private final String DIGITS = &quot;[0-9]+&quot;;\n&gt; and change TextUtils.getMatcher to take Pattern objects directly.\n&gt; \n&gt; While the fields are still instantiated at class-loading time, Patterns do not \n&gt; share the problems of Strings, because they are not interned and do not equal \n&gt; even if the pattern string is the same (the Pattern class does not override \n&gt; equals(), but shouldn&#39;t we use IdentityHashMap for the Matcher cache anyway?)\n&gt; \n&gt; All the best,\n&gt; \n&gt; Christian\n&gt; \n&gt; On Thursday 02 June 2005 21:13, Gordon Mohr wrote:\n&gt; \n&gt;&gt;I like this change, but fear subtle bugs if the same thread needs two\n&gt;&gt;Matchers of the same pattern. It&#39;d be nice to be able to use the\n&gt;&gt;TextUtils.getMatcher() idiom consistently and fearlessly, without\n&gt;&gt;having to know if any other frames above (or in the future below\n&gt;&gt;you) want to use the same matcher.\n&gt;&gt;\n&gt;&gt;Thus I&#39;d suggest removing the map entry for the requested matcher\n&gt;&gt;when it is requested, and bringing back freeMatcher() to put it back\n&gt;&gt;when a user is done.\n&gt;&gt;\n&gt;&gt;Then, in the rare cases where a second matcher of the same pattern\n&gt;&gt;is needed, a new one will be created, but there will be no risk of\n&gt;&gt;cross-corruption.\n&gt;&gt;\n&gt;&gt;(Forgetting to do a freeMatcher() would lose the efficiency of reuse,\n&gt;&gt;but otherwise be harmless.)\n&gt;&gt;\n&gt;&gt;- Gordon\n\n"}}