{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":168599281,"authorName":"Michael Stack","from":"Michael Stack &lt;stack@...&gt;","replyTo":"LIST","senderId":"9m0HcAIyitzKR9Ofzg_CkNa3dXXTJoiK-IWcY5H4uszGeov_I-n_pZHdEWfvNsCMNLvgiogxBwgZX48jldJMv9EN4iTt9kV8","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [archive-crawler] start of tests for LongFPSet","postDate":"1074717104","msgId":253,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQwMEVFMUIwLjcwMjA3MDNAYXJjaGl2ZS5vcmc+","inReplyToHeader":"PDQwMEU5QTgxLjYwOTAzMDdAamFtZXNjLm5ldD4=","referencesHeader":"PDQwMEU5QTgxLjYwOTAzMDdAamFtZXNjLm5ldD4="},"prevInTopic":251,"nextInTopic":0,"prevInTime":252,"nextInTime":254,"topicId":251,"numMessagesInTopic":2,"msgSnippet":"Thanks for the below.  Committed. St.Ack","rawEmail":"Return-Path: &lt;stack@...&gt;\r\nX-Sender: stack@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 18401 invoked from network); 21 Jan 2004 20:38:06 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m1.grp.scd.yahoo.com with QMQP; 21 Jan 2004 20:38:06 -0000\r\nReceived: from unknown (HELO ia00524.archive.org) (209.237.232.202)\n  by mta3.grp.scd.yahoo.com with SMTP; 21 Jan 2004 20:38:06 -0000\r\nReceived: (qmail 19798 invoked by uid 100); 21 Jan 2004 20:35:44 -0000\r\nReceived: from b116-dyn-60.archive.org (HELO archive.org) (stack@...@209.237.240.60)\n  by mail-dev.archive.org with SMTP; 21 Jan 2004 20:35:44 -0000\r\nMessage-ID: &lt;400EE1B0.7020703@...&gt;\r\nDate: Wed, 21 Jan 2004 12:31:44 -0800\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.5) Gecko/20031007\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: archive-crawler@yahoogroups.com\r\nReferences: &lt;400E9A81.6090307@...&gt;\r\nIn-Reply-To: &lt;400E9A81.6090307@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Spam-DCC: : \r\nX-Spam-Checker-Version: SpamAssassin 2.63 (2004-01-11) on ia00524.archive.org\r\nX-Spam-Level: \r\nX-Spam-Status: No, hits=-2.4 required=6.0 tests=AWL,BAYES_00,HTML_MESSAGE,\n\tREMOVE_REMOVAL_2WORD autolearn=no version=2.63\r\nX-eGroups-Remote-IP: 209.237.232.202\r\nFrom: Michael Stack &lt;stack@...&gt;\r\nSubject: Re: [archive-crawler] start of tests for LongFPSet\r\nX-Yahoo-Group-Post: member; u=168599281\r\n\r\nThanks for the below.  Committed.\nSt.Ack\n\nJames Casey wrote:\n\n&gt;Hi there,\n&gt;\n&gt;here&#39;s what I&#39;ve done so far for LongFPSet.  It&#39;s gotten held up because \n&gt;of the bug I&#39;ve found, but this is mostly just javadoc changes, with \n&gt;some small tidyups in terms of ctors and method visibility.\n&gt;\n&gt;I&#39;d included the patch, and a detailed changelog for it.\n&gt;\n&gt;cheers,\n&gt;\n&gt;james.\n&gt;\n&gt; \n&gt;\n&gt;\n&gt;Yahoo! Groups Links\n&gt;\n&gt;To visit your group on the web, go to:\n&gt; http://groups.yahoo.com/group/archive-crawler/\n&gt;\n&gt;To unsubscribe from this group, send an email to:\n&gt; archive-crawler-unsubscribe@yahoogroups.com\n&gt;\n&gt;Your use of Yahoo! Groups is subject to:\n&gt; http://docs.yahoo.com/info/terms/ \n&gt;\n&gt;  \n&gt;\n&gt;------------------------------------------------------------------------\n&gt;\n&gt;Patch Changelog\n&gt;===============\n&gt;\n&gt;LongFPSet.java:\n&gt;* Added javadoc\n&gt;\n&gt;AbstractLongFPSet.java:\n&gt;* Added java doc.\n&gt;* removed some javadoc from public methods and pointed to the LongFPSet \n&gt;  javadoc instead\n&gt;* added contructor AbstractLongFPSet(capacityPowerOfTwo, loadFactor)  to\n&gt;  reduce number of variables that are modified by subclasses directly\n&gt;* made startIndexFor() and indexFor() private, since they are never used \n&gt;  by subclasses\n&gt;* made relocate() protected, not default access, like all other abstract\n&gt;  methods\n&gt;* created asDataSlot(long), asEmptySlot(long) and slotHasData(long) which \n&gt;  deal with the positive to negative conversions that are used to\n&gt;  signify if a return value refers to a full or empty slot\n&gt;\n&gt;DiskLongFPSet.java:\n&gt;* Use the new ctor from AbstractLongFPSet\n&gt;* changed visibility of relocate() impl to match superclass\n&gt;\n&gt;LongFPSetTestCase.java:\n&gt;* created new abstract test class to test interface LongFPSet\n&gt;\n&gt;LongFPSetCacheTest.java:\n&gt;* created new test class\n&gt;\n&gt;MemLongFPSetTest.java:\n&gt;* created new test class\n&gt;\n&gt;QueueTestBase.java:\n&gt;* removed some autogenerated static methods which aren&#39;t used, since this \n&gt;  is an abstract class\n&gt;  \n&gt;\n&gt;------------------------------------------------------------------------\n&gt;\n&gt;Index: src/java/org/archive/util/AbstractLongFPSet.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/AbstractLongFPSet.java,v\n&gt;retrieving revision 1.3\n&gt;diff -u -u -r1.3 AbstractLongFPSet.java\n&gt;--- src/java/org/archive/util/AbstractLongFPSet.java\t3 Jan 2004 01:16:46 -0000\t1.3\n&gt;+++ src/java/org/archive/util/AbstractLongFPSet.java\t21 Jan 2004 15:15:51 -0000\n&gt;@@ -37,30 +37,50 @@\n&gt;  */\n&gt; public abstract class AbstractLongFPSet implements LongFPSet {\n&gt; \tprivate static Logger logger = Logger.getLogger(&quot;org.archive.util.AbstractLongFPSet&quot;);\n&gt;-\t// slot states\n&gt;+\n&gt;+    /** A constant used to indicate that a slot in the set storage is empty.\n&gt;+     * A zero or positive value means slot is filled\n&gt;+     */\n&gt; \tprotected static byte EMPTY = -1;\n&gt;-\t// zero or positive means slot is filled\n&gt; \n&gt;+    /** the capacity of this set, specified as the exponent of a power of 2 */\n&gt; \tprotected int capacityPowerOfTwo;\n&gt;+\n&gt;+    /** the load factor, as a fraction.  This gives the amount of free space\n&gt;+     * to keep in the Set. */\n&gt; \tprotected float loadFactor;\n&gt;+\n&gt;+    /** The current number of elements in the set */\n&gt; \tprotected long count;\n&gt; \n&gt;-\t/**\n&gt;-\t * @param val\n&gt;-\t * @return True if contains passed value.\n&gt;+    /** Create a new AbstractLongFPSet with a given capacity and load Factor\n&gt;+     *\n&gt;+     * @param capacityPowerOfTwo The capacity as the exponent of a power of 2.\n&gt;+     *  e.g if the capacity is &lt;code&gt;4&lt;/code&gt; this means &lt;code&gt;2^^4&lt;/code&gt;\n&gt;+     * entries\n&gt;+     * @param loadFactor the load factor for the set\n&gt;+     */\n&gt;+    public AbstractLongFPSet(final int capacityPowerOfTwo, float loadFactor) {\n&gt;+        this.capacityPowerOfTwo = capacityPowerOfTwo;\n&gt;+        this.loadFactor = loadFactor;\n&gt;+        this.count = 0;\n&gt;+    }\n&gt;+\n&gt;+\t/* @(non-Javadoc)\n&gt;+     * @see org.archive.util.LongFPSet#contains(long)\n&gt; \t */\n&gt; \tpublic boolean contains(long val) {\n&gt; \t\tlong i = indexFor(val);\n&gt;-\t\tif(i&gt;=0) {\n&gt;+\t\tif(slotHasData(i)) {\n&gt; \t\t\tnoteAccess(i);\n&gt; \t\t\treturn true;\n&gt; \t\t}\n&gt; \t\treturn false;\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;+\t/** Check the state of a slot in the storage.\n&gt; \t * \n&gt;-\t * @param i\n&gt;+\t * @param i the index of the slot to check\n&gt; \t * @return -1 if slot is filled; nonegative if full. \n&gt; \t */\n&gt; \tprotected abstract int getSlotState(long i);\n&gt;@@ -74,40 +94,41 @@\n&gt; \t\t// cache subclasses may use to update access counts, etc.\t\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;-\t * @return Number of values in the set.\n&gt;+\t/* @(non-Javadoc)\n&gt;+     * @see org.archive.util.LongFPSet#count()\n&gt; \t */\n&gt; \tpublic long count() {\n&gt; \t\treturn count;\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;-\t * Add the given value. \n&gt;-\t * \n&gt;-\t * @param val\n&gt;-\t * @return true if set has changed\n&gt;+\t/* @(non-Javadoc)\n&gt;+     * @see org.archive.util.LongFPSet#add(long)\n&gt; \t */\n&gt; \tpublic boolean add(long val) {\n&gt; \t\tlogger.finest(&quot;Adding &quot;+val);\n&gt; \t\tlong i = indexFor(val);\n&gt;-\t\tif (i&gt;=0) {\n&gt;+\t\tif (slotHasData(i)) {\n&gt; \t\t\t// positive index indicates already in set\n&gt; \t\t\treturn false;\n&gt; \t\t}\n&gt;-\t\tcount++;\n&gt;-\t\tif(count&gt;(loadFactor*(1&lt;&lt;capacityPowerOfTwo))) {\n&gt;+        // we have a possible slot now, which is encoded asa negative number\n&gt;+\n&gt;+        // check for space, and grow if needed\n&gt;+        count++;\n&gt;+        if(count&gt;(loadFactor*(1&lt;&lt;capacityPowerOfTwo))) {\n&gt; \t\t\tmakeSpace();\n&gt; \t\t\t// find new i\n&gt; \t\t\ti = indexFor(val);\n&gt; \t\t\tassert i &lt; 0 : &quot;slot should be empty&quot;;\n&gt; \t\t}\n&gt;-\t\ti = -(i + 1); // convert to positive index\n&gt;-\t\tsetAt(i, val);\n&gt;-\t\tnoteAccess(i);\n&gt;-\t\treturn true;\n&gt;+\n&gt;+        i = asDataSlot(i); // convert to positive index\n&gt;+        setAt(i, val);\n&gt;+        noteAccess(i);\n&gt;+        return true;\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;+    /**\n&gt; \t * Make additional space to keep the load under the target\n&gt; \t * loadFactor level. Subclasses may grow or discard entries\n&gt; \t * to satisfy. \n&gt;@@ -118,30 +139,36 @@\n&gt; \t/**\n&gt; \t * Set the stored value at the given slot. \n&gt; \t * \n&gt;-\t * @param i\n&gt;-\t * @param l\n&gt;+\t * @param i the slot index\n&gt;+\t * @param l the value to set\n&gt; \t */\n&gt; \tprotected abstract void setAt(long i, long l);\n&gt; \n&gt; \t/**\n&gt; \t * Get the stored value at the given slot. \n&gt;-\t * @param i\n&gt;+\t * @param i the slot index\n&gt; \t * @return The stored value at the given slot. \n&gt; \t */\n&gt; \tprotected abstract long getAt(long i);\n&gt; \n&gt;-\t/**\n&gt;-\t * @param val\n&gt;+\t/** Given a value, check the store for it&#39;s existence. If it exists, it\n&gt;+     * will return the index where the value resides.  Otherwise it return\n&gt;+     * an encoded index, which is a possible storage location for the value.\n&gt;+     *\n&gt;+     * Note, if we have a loading factor &lt; 1.0, there should always be an\n&gt;+     * empty location where we can store the value\n&gt;+     *\n&gt;+\t * @param val the fingerprint value to check for\n&gt; \t * @return The (positive) index where the value already resides, \n&gt; \t * or an empty index where it could be inserted (encoded as a\n&gt; \t * negative number). \n&gt; \t */\n&gt;-\tprotected long indexFor(long val) {\n&gt;+\tprivate long indexFor(long val) {\n&gt; \t\tlong candidateIndex = startIndexFor(val);\n&gt; \t\twhile (true) {\n&gt; \t\t\tif (getSlotState(candidateIndex) &lt; 0) {\n&gt; \t\t\t\t// slot empty; return negative number encoding index\n&gt;-\t\t\t\treturn -candidateIndex - 1;\n&gt;+\t\t\t\treturn asEmptySlot(candidateIndex);\n&gt; \t\t\t}\n&gt; \t\t\tif (getAt(candidateIndex) == val) {\n&gt; \t\t\t\t// already present; return positive index\n&gt;@@ -154,7 +181,7 @@\n&gt; \t\t}\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;+    /**\n&gt; \t * Return the recommended storage index for the given value. \n&gt; \t * Assumes values are already well-distributed; merely uses\n&gt; \t * high-order bits. \n&gt;@@ -162,19 +189,16 @@\n&gt; \t * @param val\n&gt; \t * @return The recommended storage index for the given value. \n&gt; \t */\n&gt;-\tprotected long startIndexFor(long val) {\n&gt;+\tprivate long startIndexFor(long val) {\n&gt; \t\treturn (val &gt;&gt;&gt; (64 - capacityPowerOfTwo));\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;-\t * Remove the given value.\n&gt;-\t * \n&gt;-\t * @param l\n&gt;-\t * @return True if we removed given value.\n&gt;+\t/* @(non-Javadoc)\n&gt;+     * @see org.archive.util.LongFPSet#remove(long)\n&gt; \t */\n&gt; \tpublic boolean remove(long l) {\n&gt; \t\tlong i = indexFor(l);\n&gt;-\t\tif (i&lt;0) {\n&gt;+\t\tif (!slotHasData(i)) {\n&gt; \t\t\t// not present, not changed\n&gt; \t\t\treturn false;\n&gt; \t\t}\n&gt;@@ -204,14 +228,15 @@\n&gt; \t\t\tlong newIndex = indexFor(val);\n&gt; \t\t\tif(newIndex!=probeIndex) {\n&gt; \t\t\t\t// value must shift down\n&gt;-\t\t\t\tnewIndex = -(newIndex+1); // positivize\n&gt;+\t\t\t\tnewIndex = asDataSlot(newIndex); // positivize\n&gt; \t\t\t\trelocate(val, probeIndex, newIndex);\n&gt; \t\t\t}\n&gt; \t\t\tprobeIndex++;\n&gt; \t\t}\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;+\n&gt;+    /**\n&gt; \t * @param index\n&gt; \t */\n&gt; \tprotected abstract void clearAt(long index);\n&gt;@@ -219,7 +244,7 @@\n&gt; \t/**\n&gt; \t * \n&gt; \t */\n&gt;-\tabstract void relocate(long value, long fromIndex, long toIndex);\n&gt;+\tprotected abstract void relocate(long value, long fromIndex, long toIndex);\n&gt; \n&gt; \t/** \n&gt; \t * Low-cost, non-definitive (except when true) contains\n&gt;@@ -231,4 +256,39 @@\n&gt; \t\treturn false;\n&gt; \t}\n&gt; \n&gt;+    /**\n&gt;+     * given a slot index, which could or could not be empty, return it as\n&gt;+     * a slot index indicating an non-empty slot\n&gt;+     *\n&gt;+     * @param index the slot index to convert\n&gt;+     * @return the index, converted to represent an slot with data\n&gt;+     */\n&gt;+    private long asDataSlot(final long index) {\n&gt;+        if(slotHasData(index)) { // slot already has data\n&gt;+            return index;\n&gt;+        }\n&gt;+        return -(index + 1);\n&gt;+    }\n&gt;+\n&gt;+    /** given a slot index, which could or could not be empty, return it as\n&gt;+     * a slot index indicating an empty slot\n&gt;+     * @param index the slot index to convert\n&gt;+     * @return the index, converted to represent an empty slot\n&gt;+     */\n&gt;+    private long asEmptySlot(final long index) {\n&gt;+        if(!slotHasData(index)) { // already empty slot\n&gt;+            return index;\n&gt;+        }\n&gt;+        return -index - 1;\n&gt;+    }\n&gt;+\n&gt;+    /** does this index represent a slot with data?\n&gt;+     *\n&gt;+     * @param index the index to check\n&gt;+     * @return &lt;code&gt;true&lt;/code&gt; if the slot has data\n&gt;+     */\n&gt;+    private boolean slotHasData(final long index) {\n&gt;+\n&gt;+        return index &gt;= 0;\n&gt;+    }\n&gt; }\n&gt;Index: src/java/org/archive/util/DiskLongFPSet.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/DiskLongFPSet.java,v\n&gt;retrieving revision 1.2\n&gt;diff -u -u -r1.2 DiskLongFPSet.java\n&gt;--- src/java/org/archive/util/DiskLongFPSet.java\t3 Jan 2004 01:16:46 -0000\t1.2\n&gt;+++ src/java/org/archive/util/DiskLongFPSet.java\t21 Jan 2004 15:15:51 -0000\n&gt;@@ -59,8 +59,7 @@\n&gt; \t * @throws IOException\n&gt; \t */\n&gt; \tpublic DiskLongFPSet(File dir, String name, int capacityPowerOfTwo, float loadFactor) throws IOException {\n&gt;-\t\tthis.capacityPowerOfTwo = capacityPowerOfTwo;\n&gt;-\t\tthis.loadFactor = loadFactor;\n&gt;+\t\tsuper(capacityPowerOfTwo, loadFactor);\n&gt; \t\tdisk = new File(dir, name+&quot;.fps&quot;);\n&gt; \t\tif(disk.exists()) {\n&gt; \t\t\tdisk.delete();\n&gt;@@ -70,7 +69,6 @@\n&gt; \t\t\trawRafile.writeByte(EMPTY);\n&gt; \t\t\trawRafile.writeLong(0);\n&gt; \t\t}\n&gt;-\t\tcount = 0;\n&gt; \t}\n&gt; \n&gt; \t/**\n&gt;@@ -153,7 +151,7 @@\n&gt; \t/* (non-Javadoc)\n&gt; \t * @see org.archive.util.AbstractLongFPSet#relocate(long, long, long)\n&gt; \t */\n&gt;-\tvoid relocate(long value, long fromIndex, long toIndex) {\n&gt;+\tprotected void relocate(long value, long fromIndex, long toIndex) {\n&gt; \t\tclearAt(fromIndex);\n&gt; \t\tsetAt(toIndex,value);\n&gt; \t}\n&gt;Index: src/java/org/archive/util/LongFPSet.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/LongFPSet.java,v\n&gt;retrieving revision 1.2\n&gt;diff -u -u -r1.2 LongFPSet.java\n&gt;--- src/java/org/archive/util/LongFPSet.java\t3 Jan 2004 01:16:46 -0000\t1.2\n&gt;+++ src/java/org/archive/util/LongFPSet.java\t21 Jan 2004 15:15:51 -0000\n&gt;@@ -29,9 +29,30 @@\n&gt;  * @author Gordon Mohr\n&gt;  */\n&gt; public interface LongFPSet {\n&gt;+    /**\n&gt;+     * Add a fingerprint to the set.\n&gt;+     * @param l the fingerprint to add\n&gt;+     * @return &lt;code&gt;true&lt;/code&gt; if set has changed with this addition\n&gt;+     */\n&gt; \tboolean add(long l);\n&gt;+\n&gt;+    /**\n&gt;+     *  Does this set contain a given fingerprint.\n&gt;+     * @param l the fingerprint to check for\n&gt;+     * @return &lt;code&gt;true&lt;/code&gt; if the fingerprint is in the set\n&gt;+     */\n&gt; \tboolean contains(long l);\n&gt;+\n&gt;+    /**\n&gt;+     *  Remove a fingerprint from the set, if it is there\n&gt;+     * @param l the fingerprint to remove\n&gt;+     * @return &lt;code&gt;true&lt;/code&gt; if we removed the fingerprint\n&gt;+     */\n&gt; \tboolean remove(long l);\n&gt;+\n&gt;+    /** get the number of elements in the Set\n&gt;+     * @return the number of elements in the Set\n&gt;+     */\n&gt; \tlong count();\n&gt; \t\n&gt; \t/**\n&gt;@@ -41,8 +62,8 @@\n&gt; \t * false, fp  *MAY* still be contained -- must use\n&gt; \t * full-cost contains() to be sure. \n&gt; \t * \n&gt;-\t * @param fp\n&gt;-\t * @return True if contains passed long.\n&gt;+\t * @param fp the fingerprint to check for\n&gt;+\t * @return &lt;code&gt;true&lt;/code&gt; if contains the fingerprint\n&gt; \t */\n&gt; \tboolean quickContains(long fp);\n&gt; }\n&gt;Index: src/java/org/archive/util/LongFPSetCacheTest.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/LongFPSetCacheTest.java\n&gt;diff -N src/java/org/archive/util/LongFPSetCacheTest.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/LongFPSetCacheTest.java\t21 Jan 2004 15:15:51 -0000\n&gt;@@ -0,0 +1,73 @@\n&gt;+/* LongFPSetCacheTest\n&gt;+ *\n&gt;+ * $Id: $\n&gt;+ *\n&gt;+ * Created Wed Jan 21 09:00:29 CET 2004\n&gt;+ *\n&gt;+ *  Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.Test;\n&gt;+import junit.framework.TestCase;\n&gt;+import junit.framework.TestSuite;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for LongFPSetCache\n&gt;+ * \n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+public class LongFPSetCacheTest extends LongFPSetTestCase {\n&gt;+    /**\n&gt;+     * Create a new LongFPSetCacheTest object\n&gt;+     * \n&gt;+     * @param testName the name of the test\n&gt;+     */\n&gt;+    public LongFPSetCacheTest(final String testName) {\n&gt;+        super(testName);\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * run all the tests for LongFPSetCacheTest\n&gt;+     * \n&gt;+     * @param argv the command line arguments\n&gt;+     */\n&gt;+    public static void main(String argv[]) {\n&gt;+        junit.textui.TestRunner.run(suite());\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * return the suite of tests for LongFPSetCacheTest\n&gt;+     * \n&gt;+     * @return the suite of test\n&gt;+     */\n&gt;+    public static Test suite() {\n&gt;+        return new TestSuite(LongFPSetCacheTest.class);\n&gt;+    }\n&gt;+\n&gt;+    LongFPSet makeLongFPSet() {\n&gt;+        return new LongFPSetCache();\n&gt;+    }\n&gt;+\n&gt;+\n&gt;+    // TODO - implement test methods in LongFPSetCacheTest\n&gt;+}\n&gt;+\n&gt;Index: src/java/org/archive/util/LongFPSetTestCase.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/LongFPSetTestCase.java\n&gt;diff -N src/java/org/archive/util/LongFPSetTestCase.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/LongFPSetTestCase.java\t21 Jan 2004 15:15:51 -0000\n&gt;@@ -0,0 +1,136 @@\n&gt;+/* LongFPSetTestCase\n&gt;+ *\n&gt;+ * $Id: $\n&gt;+ *\n&gt;+ * Created Wed Jan 21 09:00:29 CET 2004\n&gt;+ *\n&gt;+ * Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.TestCase;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for LongFPSet.  This is an abstract class which defines\n&gt;+ * the generic tests that test the {@link LongFPSet} interface.  Subclasses\n&gt;+ * may test specifics of {@link LongFPSet} subclass implementations\n&gt;+ * \n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+abstract public class LongFPSetTestCase extends TestCase {\n&gt;+\n&gt;+    /** the unerlying FPSet we wish to test */\n&gt;+    private LongFPSet fpSet;\n&gt;+\n&gt;+    /**\n&gt;+     * Create a new LongFPSetTest object\n&gt;+     * \n&gt;+     * @param testName the name of the test\n&gt;+     */\n&gt;+    public LongFPSetTestCase(final String testName) {\n&gt;+        super(testName);\n&gt;+    }\n&gt;+\n&gt;+    public void setUp() {\n&gt;+        fpSet = makeLongFPSet();\n&gt;+    }\n&gt;+\n&gt;+    abstract LongFPSet makeLongFPSet();\n&gt;+\n&gt;+    /** check that we can add fingerprints */\n&gt;+    public void testAdd() {\n&gt;+        long l1 = (long)1234;\n&gt;+        long l2 = (long)2345;\n&gt;+\n&gt;+        assertEquals(&quot;empty set to start&quot;, 0, fpSet.count());\n&gt;+        assertTrue(&quot;set changed on addition of l1&quot;, fpSet.add(l1));\n&gt;+        assertTrue(&quot;set changed on addition of l2&quot;, fpSet.add(l2));\n&gt;+        assertFalse(&quot;set didn&#39;t change on re-addition of l1&quot;, fpSet.add(l1));\n&gt;+    }\n&gt;+\n&gt;+    /** check we can call add/remove/contains() with 0 as a value */\n&gt;+    public void testWithZero() {\n&gt;+        long zero = (long)0;\n&gt;+\n&gt;+        assertEquals(&quot;empty set to start&quot;, 0, fpSet.count());\n&gt;+        assertFalse(&quot;zero is not there&quot;, fpSet.contains(zero));\n&gt;+        assertTrue(&quot;zero added&quot;, fpSet.add(zero));\n&gt;+\n&gt;+        // now one element\n&gt;+        assertEquals(&quot;one fp in set&quot;, 1, fpSet.count());\n&gt;+        assertTrue(&quot;zero is the element&quot;, fpSet.contains(zero));\n&gt;+\n&gt;+        // and remove\n&gt;+        assertTrue(&quot;zero removed&quot;, fpSet.remove(zero));\n&gt;+        assertEquals(&quot;empty set again&quot;, 0, fpSet.count());\n&gt;+    }\n&gt;+\n&gt;+    /** check that contains() does what we expect */\n&gt;+    public void testContains() {\n&gt;+        long l1 = (long) 1234;\n&gt;+        long l2 = (long) 2345;\n&gt;+        long l3 = (long) 1334;\n&gt;+\n&gt;+        assertEquals(&quot;empty set to start&quot;, 0, fpSet.count());\n&gt;+        fpSet.add(l1);\n&gt;+        fpSet.add(l2);\n&gt;+\n&gt;+        assertTrue(&quot;contains l1&quot;, fpSet.contains(l1));\n&gt;+        assertTrue(&quot;contains l2&quot;, fpSet.contains(l2));\n&gt;+        assertFalse(&quot;does not contain l3&quot;, fpSet.contains(l3));\n&gt;+    }\n&gt;+\n&gt;+    /** test remove() works as expected */\n&gt;+    public void testRemove() {\n&gt;+        long l1 = (long) 1234;\n&gt;+\n&gt;+        assertEquals(&quot;empty set to start&quot;, 0, fpSet.count());\n&gt;+\n&gt;+        // remove before it&#39;s there\n&gt;+        assertFalse(&quot;fp not in set&quot;, fpSet.remove(l1));\n&gt;+        // now add\n&gt;+        fpSet.add(l1);\n&gt;+        // and remove again\n&gt;+        assertTrue(&quot;fp was in set&quot;, fpSet.remove(l1));\n&gt;+        // check set is empty again\n&gt;+        assertEquals(&quot;empty set again&quot;, 0, fpSet.count());\n&gt;+    }\n&gt;+\n&gt;+    /** check count works ok */\n&gt;+    public void testCount() {\n&gt;+        // JC -- set NUM to below 768 to avoid trigger a count buf\n&gt;+        // in AbstractLongFPSet\n&gt;+        final int NUM = 100;\n&gt;+        assertEquals(&quot;empty set to start&quot;, 0, fpSet.count());\n&gt;+\n&gt;+        for(int i = 1; i &lt; NUM; ++i) {\n&gt;+            fpSet.add((long)i);\n&gt;+            assertEquals(&quot;correct num&quot;, i, fpSet.count());\n&gt;+        }\n&gt;+        for (int i = NUM - 1; i &gt; 0; --i) {\n&gt;+            fpSet.remove((long) i);\n&gt;+            assertEquals(&quot;correct num&quot;, i -1, fpSet.count());\n&gt;+        }\n&gt;+        assertEquals(&quot;empty set to start&quot;, 0, fpSet.count());\n&gt;+\n&gt;+    }\n&gt;+}\n&gt;+\n&gt;Index: src/java/org/archive/util/MemLongFPSet.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/MemLongFPSet.java,v\n&gt;retrieving revision 1.2\n&gt;diff -u -u -r1.2 MemLongFPSet.java\n&gt;--- src/java/org/archive/util/MemLongFPSet.java\t3 Jan 2004 01:16:46 -0000\t1.2\n&gt;+++ src/java/org/archive/util/MemLongFPSet.java\t21 Jan 2004 15:15:51 -0000\n&gt;@@ -39,7 +39,7 @@\n&gt; \t * \n&gt; \t */\n&gt; \tpublic MemLongFPSet() {\n&gt;-\t\tthis(DEFAULT_CAPACITY_POWER_OF_TWO, 0.75f);\n&gt;+\t\tthis(DEFAULT_CAPACITY_POWER_OF_TWO, DEFAULT_LOAD_FACTOR);\n&gt; \t}\n&gt; \n&gt; \t/**\n&gt;@@ -47,14 +47,12 @@\n&gt; \t * @param loadFactor\n&gt; \t */\n&gt; \tpublic MemLongFPSet(int capacityPowerOfTwo, float loadFactor) {\n&gt;-\t\tthis.capacityPowerOfTwo = capacityPowerOfTwo;\n&gt;-\t\tthis.loadFactor = loadFactor;\n&gt;+        super(capacityPowerOfTwo, loadFactor);\n&gt; \t\tslots = new byte[1&lt;&lt;capacityPowerOfTwo];\n&gt; \t\tfor(int i = 0; i &lt; (1&lt;&lt;capacityPowerOfTwo); i++) {\n&gt; \t\t\tslots[i]=EMPTY; // flag value for unused\n&gt; \t\t}\n&gt; \t\tvalues = new long[1&lt;&lt;capacityPowerOfTwo];\n&gt;-\t\tcount = 0;\n&gt; \t}\n&gt; \n&gt; \tprotected void setAt(long i, long val) {\n&gt;Index: src/java/org/archive/util/MemLongFPSetTest.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/MemLongFPSetTest.java\n&gt;diff -N src/java/org/archive/util/MemLongFPSetTest.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/MemLongFPSetTest.java\t21 Jan 2004 15:15:51 -0000\n&gt;@@ -0,0 +1,75 @@\n&gt;+/* MemLongFPSetTest\n&gt;+ *\n&gt;+ * $Id: $\n&gt;+ *\n&gt;+ * Created Wed Jan 21 09:00:29 CET 2004\n&gt;+ *\n&gt;+ * Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ * \n&gt;+ * File: MemLongFPSetTest.java\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.Test;\n&gt;+import junit.framework.TestSuite;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for MemLongFPSet\n&gt;+ * \n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+public class MemLongFPSetTest extends LongFPSetTestCase {\n&gt;+        /**\n&gt;+         * Create a new MemLongFPSetTest object\n&gt;+         * \n&gt;+         * @param testName the name of the test\n&gt;+         */\n&gt;+        public MemLongFPSetTest(final String testName) {\n&gt;+                super(testName);\n&gt;+        }\n&gt;+\n&gt;+        /**\n&gt;+         * run all the tests for MemLongFPSetTest\n&gt;+         * \n&gt;+         * @param argv the command line arguments\n&gt;+         */\n&gt;+        public static void main(String argv[]) {\n&gt;+                junit.textui.TestRunner.run(suite());\n&gt;+        }\n&gt;+\n&gt;+        /**\n&gt;+         * return the suite of tests for MemLongFPSetTest\n&gt;+         * \n&gt;+         * @return the suite of test\n&gt;+         */\n&gt;+        public static Test suite() {\n&gt;+                return new TestSuite(MemLongFPSetTest.class);\n&gt;+        }\n&gt;+\n&gt;+        LongFPSet makeLongFPSet() {\n&gt;+                return new MemLongFPSet();\n&gt;+        }\n&gt;+\n&gt;+        public void testFoo() {\n&gt;+\n&gt;+        }\n&gt;+}\n&gt;+\n&gt;Index: src/java/org/archive/util/QueueTestBase.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/QueueTestBase.java,v\n&gt;retrieving revision 1.1\n&gt;diff -u -u -r1.1 QueueTestBase.java\n&gt;--- src/java/org/archive/util/QueueTestBase.java\t20 Jan 2004 22:56:34 -0000\t1.1\n&gt;+++ src/java/org/archive/util/QueueTestBase.java\t21 Jan 2004 15:15:51 -0000\n&gt;@@ -27,10 +27,6 @@\n&gt; \n&gt; import java.util.NoSuchElementException;\n&gt; \n&gt;-import junit.framework.Test;\n&gt;-import junit.framework.TestSuite;\n&gt;-\n&gt;-\n&gt; /**\n&gt;  * JUnit test suite for Queue.  It&#39;s an abstract class which is implemented by\n&gt;  * each queue implementation\n&gt;@@ -46,24 +42,6 @@\n&gt;      */\n&gt;     public QueueTestBase(final String testName) {\n&gt;         super(testName);\n&gt;-    }\n&gt;-\n&gt;-    /**\n&gt;-     * run all the tests for PaddingStringBufferTest\n&gt;-     *\n&gt;-     * @param argv the command line arguments\n&gt;-     */\n&gt;-    public static void main(String argv[]) {\n&gt;-        junit.textui.TestRunner.run(suite());\n&gt;-    }\n&gt;-\n&gt;-    /**\n&gt;-     * return the suite of tests for PaddingStringBufferTest\n&gt;-     *\n&gt;-     * @return the suite of test\n&gt;-     */\n&gt;-    public static Test suite() {\n&gt;-        return new TestSuite(PaddingStringBufferTest.class);\n&gt;     }\n&gt; \n&gt;     public void setUp() throws Exception {\n&gt;  \n&gt;\n\n\n\n"}}