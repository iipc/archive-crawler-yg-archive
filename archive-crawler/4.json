{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":137285340,"authorName":"Gordon Mohr","from":"&quot;Gordon Mohr&quot; &lt;gojomo@...&gt;","profile":"gojomo","replyTo":"LIST","senderId":"B0JDcm2HirPei2zvf6S8BwXkLWm0fPMG045OxffCgtfleLymVw1T9MlptmlUoI6_dD-_E1RCTaBZJz9uqub07sJBe7xDAG7P1w","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [archive-crawler] Design thoughts: a single worker thread","postDate":"1045076786","msgId":4,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDAwNzUwMWMyZDJjOSRkYTkxNGM1MCQzYWViZWRkMUBnb2pvdmFpbz4=","referencesHeader":"PDJlZWMwMWMyZDJiZSRjYjFiYzg1MCRkNTAwYThjMEBSZWRkeUdCPg=="},"prevInTopic":3,"nextInTopic":0,"prevInTime":3,"nextInTime":5,"topicId":3,"numMessagesInTopic":2,"msgSnippet":"Hi, Reddy! ... Yes, this outline most easily maps to blocking I/O. Per a discussion last Thursday, we d initially like to get up and running with the familiar","rawEmail":"Return-Path: &lt;gojomo@...&gt;\r\nX-Sender: gojomo@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (EGP: mail-8_2_3_4); 12 Feb 2003 19:08:02 -0000\r\nReceived: (qmail 59895 invoked from network); 12 Feb 2003 19:06:35 -0000\r\nReceived: from unknown (66.218.66.218)\n  by m10.grp.scd.yahoo.com with QMQP; 12 Feb 2003 19:06:35 -0000\r\nReceived: from unknown (HELO mail.archive.org) (209.237.232.3)\n  by mta3.grp.scd.yahoo.com with SMTP; 12 Feb 2003 19:06:35 -0000\r\nReceived: from gojovaio (dynamic-58.archive.org [209.237.235.58])\n\tby mail.archive.org (8.10.2/8.10.2) with SMTP id h1CIUBd02455\n\tfor &lt;archive-crawler@yahoogroups.com&gt;; Wed, 12 Feb 2003 10:30:11 -0800\r\nMessage-ID: &lt;007501c2d2c9$da914c50$3aebedd1@gojovaio&gt;\r\nTo: &lt;archive-crawler@yahoogroups.com&gt;\r\nReferences: &lt;2eec01c2d2be$cb1bc850$d500a8c0@ReddyGB&gt;\r\nSubject: Re: [archive-crawler] Design thoughts: a single worker thread\r\nDate: Wed, 12 Feb 2003 11:06:26 -0800\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;iso-8859-1&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook Express 6.00.2720.3000\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2600.0000\r\nFrom: &quot;Gordon Mohr&quot; &lt;gojomo@...&gt;\r\nX-Yahoo-Group-Post: member; u=137285340\r\nX-Yahoo-Profile: gojomo\r\n\r\nHi, Reddy!\n\nYou write:\n&gt; I assume that the worker thread is doing synchronous I/O. We are \n&gt; not sure yet on what mode we have finalized, synchronous I/O or \n&gt; asynchronous I/O ?\n\nYes, this outline most easily maps to blocking I/O. Per a discussion\nlast Thursday, we&#39;d initially like to get up and running with the\nfamiliar blocking I/O approach. Where possible we&#39;ll detach the \nraw fetching/communication code from the other policy and analysis,\nso that if/when the Windows NBIO problems are better understood, or\nwe need the extra performance of NBIO, we can revisit the issue then.\n\n&gt; The following views are based on the belief that we are following \n&gt; the Mercator design at the higher level.\n&gt; \n&gt; [Gordon] - Things like robots.txt or politeness could be handled in \n&gt; a very-smart &#39;frontier&#39; object, or as one or more &#39;preprocessors&#39; \n&gt; which occasionally veto/snooze offered URIs, pushing them back to \n&gt; the frontier for later processing\n&gt; [Reddy] - We feel that politeness cannot be handled in the preprocessing \n&gt; modules since preprocessing works on a single candidateURI at a time. \n&gt; It is the frontier which has to do this work much like what is done in \n&gt; Mercator. Mercator&#39;s frontier maintains one queue per worker thread \n&gt; based on the hostnames and the politeness factor.\n\nI think there&#39;s a continuum of possibilities for how the decisionmaking\nis split between the frontier and individual worker-threads.\n\n(This next part is just enumerating the full range of possibilities;\nI&#39;m not yet advocating a specific approach in our main \nimplementation...)\n\nAt one extreme, you could have a very dumb frontier queue which essentially\njust returns URIs first-in, first-out -- but with some mechanism for\na worker-thread to push back URIs with extra conditions about when/if they\nreappear. \n\nSo the URIs might be grabbed by...\n\n    candidateUri = frontier.nextUriFor(this.workerIdentity());\n\n...but then sometimes pushed back via...\n\n    frontier.takebackUriUntil(candidateUri,time);\nor\n    frontier.takebackAndNeverReturnTo(candidateUri,this.workerIdentity());\n\nThat&#39;s not necessarily an efficient way to hand off URIs --\nif a worker-thread is only handling 1/100th of the URI-space,\nit&#39;ll be pushing back 99/100 URIs thrown at it -- but it does\nlet the frontier be simple, while all policy decisions are\nmade in a swappable/transparent fashion at the worker-threads.\n\nAt the other extreme, each worker-thread trusts the frontier\ncompletely, assuming that it would never be handed a URI \nthat wasn&#39;t proper to retrieve. \n\nWhen considering our design as a framework for many crawling\napps, I think we should make it possible for people&#39;s plug-in\nmodules to pursue either extreme. \n\nWhen thinking about what&#39;s the optimal division for the Archive&#39;s \nneeds and deployment scenario, I tend to think that the \nworker-threads will have the best local information (about fresh \nrobots.txt directives, per-host visit histories, and per-host \napparent responsiveness), while the frontier will have better \nglobal knowledge of how duties are split and prioritized among\nworker-threads. I believe this puts somewhat more into each \nworker-thread than the classic Mercator approach.\n\n&gt; [Gordon] - In this outline, the frontier object does a lot: it&#39;s \n&gt; the URI-seen database, the URI-fetched database, the URI-prioritization \n&gt; policy, etc. etc. Could/should it be further decomposed ?\n&gt; [Reddy] - We think it should definitely be decomposed. URI-seen and \n&gt; URI-fetched databases will be simple but URI-prioritization will be a \n&gt; complex thing to handle.\n\nYes, but I also think that URI-seen and URI-fetched will become\nchallenging at the level of billions of URIs, and tend to merge\nwith the prioritization problem when considering a continuous\ncrawl.\n\n&gt; [Gordon] - Where do DNS lookups take place, and how much of an audit \n&gt; trail is generated? One possibility is that there is a &quot;DNS frontier&quot; \n&gt; just like the URI frontier. A Preprocessor module only crawls a URI if \n&gt; its domain name has already been (recently) resolved; if not, it starts \n&gt; a DNS lookup, and &quot;snoozes&quot; the URI for enough time that the name will \n&gt; probably have resolved by the time the URI again is considered.\n&gt; [Reddy] - DNS resolver would be a separate synchronous thread with its \n&gt; own expiration logic for the entries in the cache. So, it is agreed \n&gt; that the Preprocessor would snooze the crawl if the hostname is not yet \n&gt; resolved. But when it is reconsidered after resolution is done, where \n&gt; would we place the URI in the queue ? It would have to be based on \n&gt; prioritization again.\n\nThere seem to be a number of good reasons to have a sort of &quot;As\nSoon As Possible&quot; subqueue for each worker-thread -- for robots.txt\nand inline-image fetches, among others. It could also make sense \nfor fetches that were only delayed because of DNS latency to be\npushed into the ASAP pile.\n\n&gt; Other questions :\n&gt; \n&gt; - We are not sure of the role of postProcessing. What would be the \n&gt; kind of jobs done here in sequence ?\n\nPostprocessing could include on-the-fly analysis, archiving permanent\ncopies, etc. Essentially anything that requires either the whole\ndocument to be fetched (or the error status to be clear/stable), and\nyou want to do contemporaneously with the crawl. On-the-fly incremental\npage-priority recalculation (eg Xyleme approach or others) could be \nhandled here. \n\n&gt; - When would we revisit the rejected ( based on politeness policy ) \n&gt; URIs ? I assume that these URIs would be retrieved from the database \n&gt; at a later point of time and re-scheduled based on the prioritization \n&gt; policy.\n\nI think there are many potential answers... the easiest being that\nthe frontier can manage a &quot;don&#39;t revisit until&quot; timestamp on any\ngiven URI. \n\n&gt; Can we have a brief chat on this tomorrow morning 9 am IST. If not \n&gt; please let us know a suitable timing. We would reach better \n&gt; understanding if we discuss.\n\nPossibly -- pending our discussion here this afternoon. \n\n- Gordon\n\n\n"}}