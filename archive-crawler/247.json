{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":168599281,"authorName":"Michael Stack","from":"Michael Stack &lt;stack@...&gt;","replyTo":"LIST","senderId":"SCyA0kCgipoUVHWEq206ItHMv-eGOO0F3SJBer0HLYUCuWcK_OZ5--ycujtll27n1QUHB_fqnjJEbfTPwzlEgrwlh8oAGZ82","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [archive-crawler] org.archive.util tests patch","postDate":"1074639803","msgId":247,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQwMERCM0JCLjEwMDA0QGFyY2hpdmUub3JnPg==","inReplyToHeader":"PDQwMEJEM0MzLjEwOTA0MDFAamFtZXNjLm5ldD4=","referencesHeader":"PDQwMEJEM0MzLjEwOTA0MDFAamFtZXNjLm5ldD4="},"prevInTopic":241,"nextInTopic":249,"prevInTime":246,"nextInTime":248,"topicId":241,"numMessagesInTopic":4,"msgSnippet":"Thank you for the high quality contribution.   I committed your patch and added you as a Heritrix contributor. See below for response to your remarks. ... ","rawEmail":"Return-Path: &lt;stack@...&gt;\r\nX-Sender: stack@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 96326 invoked from network); 20 Jan 2004 23:09:31 -0000\r\nReceived: from unknown (66.218.66.167)\n  by m18.grp.scd.yahoo.com with QMQP; 20 Jan 2004 23:09:31 -0000\r\nReceived: from unknown (HELO ia00524.archive.org) (209.237.232.202)\n  by mta6.grp.scd.yahoo.com with SMTP; 20 Jan 2004 23:09:31 -0000\r\nReceived: (qmail 14656 invoked by uid 100); 20 Jan 2004 23:07:19 -0000\r\nReceived: from b116-dyn-60.archive.org (HELO archive.org) (stack@...@209.237.240.60)\n  by mail-dev.archive.org with SMTP; 20 Jan 2004 23:07:19 -0000\r\nMessage-ID: &lt;400DB3BB.10004@...&gt;\r\nDate: Tue, 20 Jan 2004 15:03:23 -0800\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.5) Gecko/20031007\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: archive-crawler@yahoogroups.com\r\nReferences: &lt;400BD3C3.1090401@...&gt;\r\nIn-Reply-To: &lt;400BD3C3.1090401@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Spam-Status: No, hits=-2.7 required=6.0\n\ttests=AWL,BAYES_01,EMAIL_ATTRIBUTION,HTML_MESSAGE,IN_REP_TO,\n\t      QUOTED_EMAIL_TEXT,REFERENCES,REPLY_WITH_QUOTES,\n\t      USER_AGENT_MOZILLA_UA\n\tautolearn=ham version=2.55\r\nX-Spam-Level: \r\nX-Spam-Checker-Version: SpamAssassin 2.55 (1.174.2.19-2003-05-19-exp)\r\nX-eGroups-Remote-IP: 209.237.232.202\r\nFrom: Michael Stack &lt;stack@...&gt;\r\nSubject: Re: [archive-crawler] org.archive.util tests patch\r\nX-Yahoo-Group-Post: member; u=168599281\r\n\r\nThank you for the high quality contribution.   I committed your patch \nand added you as a Heritrix contributor.\n\nSee below for response to your remarks.\n\nJames Casey wrote:\n\n&gt;Hi all,\n&gt;\n&gt;\n&gt;There is more work I want to do on the queue classes, and then I&#39;ll look \n&gt;at the Fingerprint set classes.\n&gt;\n&gt;  \n&gt;\nSounds good.\n\n&gt;A few comments, basically things I didn&#39;t change, but thought were a bit \n&gt;odd.\n&gt;\n&gt;* JavaLiterals isn&#39;t used anywhere, so I didn&#39;t test it, but I think \n&gt;there is a bug in unescape in the handling of &quot;&#92;&#92;&#92;r&quot; (it gets put into \n&gt;the string as &#39;r&#39;, not &#39;&#92;r&#39;.  Is it live code, and should I write tests \n&gt;for it ?\n&gt;\n&gt;  \n&gt;\nYeah, it looks like the &#39;&#92;&#92;&#92;r&#39; would end up in unescape.raw buffer as \njust &#39;r&#39;.  I believe JavaLiterals is about to go into use (Its a new \nclass just added by our Gordon).\n\n&gt;* MemQueue exposes all the methods from LinkedList, since it implements \n&gt;it.  Maybe encapsulating an instance would be better, so odd behaviour \n&gt;can&#39;t happen if other code goes behind your back and casts it to a \n&gt;LinkedList (I can do these changes if you like).\n&gt;  \n&gt;\nThis sounds reasonable.\n\nGood Stuff James,\nThanks again,\nSt.Ack\n\n&gt;cheers,\n&gt;\n&gt;james.\n&gt;\n&gt; \n&gt;\n&gt;Yahoo! Groups Links\n&gt;\n&gt;To visit your group on the web, go to:\n&gt; http://groups.yahoo.com/group/archive-crawler/\n&gt;\n&gt;To unsubscribe from this group, send an email to:\n&gt; archive-crawler-unsubscribe@yahoogroups.com\n&gt;\n&gt;Your use of Yahoo! Groups is subject to:\n&gt; http://docs.yahoo.com/info/terms/ \n&gt;\n&gt;  \n&gt;\n&gt;------------------------------------------------------------------------\n&gt;\n&gt;Index: src/java/org/archive/util/ArchiveUtils.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/ArchiveUtils.java,v\n&gt;retrieving revision 1.3\n&gt;diff -u -u -r1.3 ArchiveUtils.java\n&gt;--- src/java/org/archive/util/ArchiveUtils.java\t16 Jan 2004 01:51:03 -0000\t1.3\n&gt;+++ src/java/org/archive/util/ArchiveUtils.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -132,7 +132,8 @@\n&gt; \t/**\n&gt; \t * Utility function for parsing arc-style date stamps\n&gt; \t * in the format yyyMMddHHmmssSSS.\n&gt;-\t * Date stamps are in the UTC time zone\n&gt;+\t * Date stamps are in the UTC time zone.  The whole string will not be\n&gt;+     * parsed, only the first 17 digits.\n&gt; \t * \n&gt; \t * @param date an arc-style formatted date stamp\n&gt; \t * @return the Date corresponding to the date stamp string\n&gt;@@ -145,7 +146,8 @@\n&gt; \t/**\n&gt; \t * Utility function for parsing arc-style date stamps\n&gt; \t * in the format yyyMMddHHmmss.\n&gt;-\t * Date stamps are in the UTC time zone\n&gt;+\t * Date stamps are in the UTC time zone.  The whole string will not be\n&gt;+     * parsed, only the first 14 digits.\n&gt; \t * \n&gt; \t * @param date an arc-style formatted date stamp\n&gt; \t * @return the Date corresponding to the date stamp string\n&gt;@@ -158,7 +160,8 @@\n&gt; \t/**\n&gt; \t * Utility function for parsing arc-style date stamps\n&gt; \t * in the format yyyMMddHHmm.\n&gt;-\t * Date stamps are in the UTC time zone\n&gt;+\t * Date stamps are in the UTC time zone.  The whole string will not be\n&gt;+     * parsed, only the first 12 digits.\n&gt; \t * \n&gt; \t * @param date an arc-style formatted date stamp\n&gt; \t * @return the Date corresponding to the date stamp string\n&gt;@@ -168,22 +171,27 @@\n&gt; \t\treturn TIMESTAMP12.parse(date);\n&gt; \t}\n&gt; \t\n&gt;-\t/**\n&gt;-\t * @param i\n&gt;-\t * @param pad\n&gt;+\t/** Convert an &lt;code&gt;int&lt;/code&gt; to a &lt;code&gt;String&lt;/code&gt;, and pad it to\n&gt;+     * &lt;code&gt;pad&lt;/code&gt; spaces.\n&gt;+\t * @param i the int\n&gt;+\t * @param pad the width to pad to.\n&gt; \t * @return String w/ padding.\n&gt; \t */\n&gt;-\tpublic static String padTo(int i, int pad) {\n&gt;+\tpublic static String padTo(final int i, final int pad) {\n&gt; \t\tString n = Integer.toString(i);\n&gt; \t\treturn padTo(n,pad);\n&gt; \t}\n&gt; \t\n&gt;-\t/**\n&gt;-\t * @param s\n&gt;-\t * @param pad\n&gt;+\t/** Pad the given &lt;code&gt;String&lt;/code&gt; to &lt;code&gt;pad&lt;/code&gt; characters wide\n&gt;+     * by pre-pending spaces.  &lt;code&gt;s&lt;/code&gt; should not be &lt;code&gt;null&lt;/code&gt;.\n&gt;+     * If &lt;code&gt;s&lt;/code&gt; is already wider than &lt;code&gt;pad&lt;/code&gt; no change is\n&gt;+     * done.\n&gt;+     *\n&gt;+\t * @param s the String to pad\n&gt;+\t * @param pad the width to pad to.\n&gt; \t * @return String w/ padding.\n&gt; \t */\n&gt;-\tpublic static String padTo(String s, int pad) {\n&gt;+\tpublic static String padTo(final String s, final int pad) {\n&gt; \t\tint l = s.length();\n&gt; \t\tStringBuffer sb = new StringBuffer();\n&gt; \t\twhile(l&lt;pad) {\n&gt;@@ -192,7 +200,8 @@\n&gt; \t\t}\n&gt; \t\tsb.append(s);\n&gt; \t\treturn sb.toString();\n&gt;-\t}\t\n&gt;+\t}\n&gt;+    \n&gt; \t/**\n&gt; \t * Example: On Windows machine file test/test.txt is converted to test&#92;test.txt \n&gt; \t * @param aFileName\n&gt;@@ -221,14 +230,28 @@\n&gt; \t/**\n&gt; \t * Tests if a file&#39;s path is absolute.\n&gt; \t * \n&gt;-\t * @param aFileName\n&gt;-\t * @return boolean\n&gt;+\t * @param aFileName the filename to check\n&gt;+\t * @return &lt;code&gt;true&lt;/code&gt; if it is an absolute file\n&gt; \t */\n&gt; \tpublic static boolean isFilePathAbsolute(String aFileName){\n&gt;+        // deal with null argument to avoid npe\n&gt;+        if(aFileName == null) {\n&gt;+            return false;\n&gt;+        }\n&gt; \t\treturn (new File(aFileName)).isAbsolute();\n&gt;  \t}\n&gt;-\t\n&gt;-\tpublic static boolean byteArrayEquals(byte[] lhs, byte[] rhs) {\n&gt;+\n&gt;+    /** check that two byte arrays are equal.  They may be &lt;code&gt;null&lt;/code&gt;.\n&gt;+     *\n&gt;+     * @param lhs a byte array\n&gt;+     * @param rhs another byte array.\n&gt;+     * @return &lt;code&gt;true&lt;/code&gt; if they are both equal (or both\n&gt;+     * &lt;code&gt;null&lt;/code&gt;)\n&gt;+     */\n&gt;+\tpublic static boolean byteArrayEquals(final byte[] lhs, final byte[] rhs) {\n&gt;+        if (lhs == null && rhs != null || lhs != null && rhs == null) {\n&gt;+            return false;\n&gt;+        }\n&gt; \t\tif (lhs==rhs) {\n&gt; \t\t\treturn true;\n&gt; \t\t}\n&gt;Index: src/java/org/archive/util/ArchiveUtilsTest.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/ArchiveUtilsTest.java\n&gt;diff -N src/java/org/archive/util/ArchiveUtilsTest.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/ArchiveUtilsTest.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -0,0 +1,251 @@\n&gt;+/* Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ * \n&gt;+ * File: ArchiveUtilsTest.java\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.Test;\n&gt;+import junit.framework.TestCase;\n&gt;+import junit.framework.TestSuite;\n&gt;+\n&gt;+import java.text.ParseException;\n&gt;+import java.util.Date;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for ArchiveUtils\n&gt;+ * \n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+public class ArchiveUtilsTest extends TestCase {\n&gt;+    /**\n&gt;+     * Create a new ArchiveUtilsTest object\n&gt;+     * \n&gt;+     * @param testName the name of the test\n&gt;+     */\n&gt;+    public ArchiveUtilsTest(final String testName) {\n&gt;+        super(testName);\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * run all the tests for ArchiveUtilsTest\n&gt;+     * \n&gt;+     * @param argv the command line arguments\n&gt;+     */\n&gt;+    public static void main(String argv[]) {\n&gt;+        junit.textui.TestRunner.run(suite());\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * return the suite of tests for ArchiveUtilsTest\n&gt;+     * \n&gt;+     * @return the suite of test\n&gt;+     */\n&gt;+    public static Test suite() {\n&gt;+        return new TestSuite(ArchiveUtilsTest.class);\n&gt;+    }\n&gt;+\n&gt;+    /** check the getXXDigitDate() methods produce valid dates*/\n&gt;+    public void testGetXXDigitDate() {\n&gt;+        // TODO - we only really test the date lengths here.  How to test\n&gt;+        // other stuff well ?\n&gt;+        final String date12 = ArchiveUtils.get12DigitDate();\n&gt;+        assertEquals(&quot;12 digits&quot;, 12, date12.length());\n&gt;+\n&gt;+        final String date14 = ArchiveUtils.get14DigitDate();\n&gt;+        assertEquals(&quot;14 digits&quot;, 14, date14.length());\n&gt;+\n&gt;+        final String date17 = ArchiveUtils.get17DigitDate();\n&gt;+        assertEquals(&quot;17 digits&quot;, 17, date17.length());\n&gt;+\n&gt;+        // now parse, and check they&#39;re all within 1 minute\n&gt;+\n&gt;+        try {\n&gt;+            final long long12 = ArchiveUtils.parse12DigitDate(date12).getTime();\n&gt;+            long long14 = ArchiveUtils.parse14DigitDate(date14).getTime();\n&gt;+            long long17 = ArchiveUtils.parse17DigitDate(date17).getTime();\n&gt;+\n&gt;+            assertClose(&quot;12 and 14 close&quot;, long12, long14, 600000);\n&gt;+            assertClose(&quot;12 and 17 close&quot;, long12, long17, 600000);\n&gt;+            assertClose(&quot;14 and 17 close&quot;, long14, long17, 600000);\n&gt;+        } catch (ParseException e) {\n&gt;+            fail(&quot;Could not parse a date : &quot; + e.getMessage());\n&gt;+        }\n&gt;+    }\n&gt;+\n&gt;+    /** check that getXXDigitDate(long) does the right thing */\n&gt;+    public void testGetXXDigitDateLong() {\n&gt;+        final long now = System.currentTimeMillis();\n&gt;+        final String date12 = ArchiveUtils.get12DigitDate(now);\n&gt;+        assertEquals(&quot;12 digits&quot;, 12, date12.length());\n&gt;+\n&gt;+        final String date14 = ArchiveUtils.get14DigitDate(now);\n&gt;+        assertEquals(&quot;14 digits&quot;, 14, date14.length());\n&gt;+        assertEquals(&quot;first twelve digits same as date12&quot;, date12, date14.substring(0, 12));\n&gt;+        final String date17 = ArchiveUtils.get17DigitDate(now);\n&gt;+        assertEquals(&quot;17 digits&quot;, 17, date17.length());\n&gt;+        assertEquals(&quot;first twelve digits same as date12&quot;, date12, date17.substring(0, 12));\n&gt;+        assertEquals(&quot;first fourteen digits same as date14&quot;, date14, date17.substring(0, 14));\n&gt;+    }\n&gt;+\n&gt;+    /** check that parseXXDigitDate() works */\n&gt;+    public void testParseXXDigitDate() throws ParseException {\n&gt;+        // given a date, check it get resolved properly\n&gt;+        // It&#39;s 02 Jan 2004, 12:40:02.111\n&gt;+        final String date = &quot;20040102124002111&quot;;\n&gt;+        try {\n&gt;+            final long long12 = ArchiveUtils.parse12DigitDate(date.substring(0, 12)).getTime();\n&gt;+            final long long14 = ArchiveUtils.parse14DigitDate(date.substring(0, 14)).getTime();\n&gt;+            final long long17 = ArchiveUtils.parse17DigitDate(date).getTime();\n&gt;+\n&gt;+            assertClose(&quot;12 and 14 close&quot;, long12, long14, 600000);\n&gt;+            assertClose(&quot;12 and 17 close&quot;, long12, long17, 600000);\n&gt;+            assertClose(&quot;14 and 17 close&quot;, long14, long17, 600000);\n&gt;+        } catch (ParseException e) {\n&gt;+            fail(&quot;Could not parse a date : &quot; + e.getMessage());\n&gt;+        }\n&gt;+    }\n&gt;+\n&gt;+    /** check that parse12DigitDate doesn&#39;t accept a bad date */\n&gt;+    public void testBad12Date() {\n&gt;+        // now try a badly formed dates\n&gt;+        assertBad12DigitDate(&quot;a-stringy-digit-date&quot;);\n&gt;+        assertBad12DigitDate(&quot;20031201&quot;); // too short\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * check that parse14DigitDate doesn&#39;t accept a bad date\n&gt;+     */\n&gt;+    public void testBad14Date() {\n&gt;+        // now try a badly formed dates\n&gt;+        assertBad14DigitDate(&quot;a-stringy-digit-date&quot;);\n&gt;+        assertBad14DigitDate(&quot;20031201&quot;); // too short\n&gt;+        assertBad14DigitDate(&quot;200401021240&quot;);  // 12 digit\n&gt;+    }\n&gt;+    /**\n&gt;+     * check that parse12DigitDate doesn&#39;t accept a bad date\n&gt;+     */\n&gt;+    public void testBad17Date() {\n&gt;+        // now try a badly formed dates\n&gt;+        assertBad17DigitDate(&quot;a-stringy-digit-date&quot;);\n&gt;+        assertBad17DigitDate(&quot;20031201&quot;); // too short\n&gt;+        assertBad17DigitDate(&quot;200401021240&quot;);  // 12 digit\n&gt;+        assertBad17DigitDate(&quot;20040102124002&quot;);  // 14 digit\n&gt;+    }\n&gt;+\n&gt;+    /** check that padTo(String) works */\n&gt;+    public void testPadToString() {\n&gt;+        assertEquals(&quot;pad to one (smaller)&quot;, &quot;foo&quot;, ArchiveUtils.padTo(&quot;foo&quot;, 1));\n&gt;+        assertEquals(&quot;pad to 0 (no sense)&quot;, &quot;foo&quot;, ArchiveUtils.padTo(&quot;foo&quot;, 0));\n&gt;+        assertEquals(&quot;pad to neg (nonsense)&quot;, &quot;foo&quot;, ArchiveUtils.padTo(&quot;foo&quot;, 0));\n&gt;+        assertEquals(&quot;pad to 4&quot;, &quot; foo&quot;, ArchiveUtils.padTo(&quot;foo&quot;, 4));\n&gt;+        assertEquals(&quot;pad to 10&quot;, &quot;       foo&quot;, ArchiveUtils.padTo(&quot;foo&quot;, 10));\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * check that padTo(int) works\n&gt;+     */\n&gt;+    public void testPadToInt() {\n&gt;+        assertEquals(&quot;pad to one (smaller)&quot;, &quot;123&quot;, ArchiveUtils.padTo(123, 1));\n&gt;+        assertEquals(&quot;pad to 0 (no sense)&quot;, &quot;123&quot;, ArchiveUtils.padTo(123, 0));\n&gt;+        assertEquals(&quot;pad to neg (nonsense)&quot;, &quot;123&quot;, ArchiveUtils.padTo(123, 0));\n&gt;+        assertEquals(&quot;pad to 4&quot;, &quot; 123&quot;, ArchiveUtils.padTo(123, 4));\n&gt;+        assertEquals(&quot;pad to 10&quot;, &quot;       123&quot;, ArchiveUtils.padTo(123, 10));\n&gt;+        assertEquals(&quot;pad -123 to 10&quot;, &quot;      -123&quot;, ArchiveUtils.padTo(-123, 10));\n&gt;+    }\n&gt;+\n&gt;+    /** check that byteArrayEquals() works */\n&gt;+    public void testByteArrayEquals() {\n&gt;+        // foo == foo2, foo != bar, foo != bar2\n&gt;+        byte[] foo = new byte[10], bar = new byte[20];\n&gt;+        byte[] foo2 = new byte[10], bar2 = new byte[10];\n&gt;+\n&gt;+        for (byte i = 0; i &lt; 10 ; ++i) {\n&gt;+            foo[i] = foo2[i] = bar[i] = i;\n&gt;+            bar2[i] = (byte)(01 + i);\n&gt;+        }\n&gt;+        assertTrue(&quot;two nulls&quot;, ArchiveUtils.byteArrayEquals(null, null));\n&gt;+        assertFalse(&quot;lhs null&quot;, ArchiveUtils.byteArrayEquals(null, foo));\n&gt;+        assertFalse(&quot;rhs null&quot;, ArchiveUtils.byteArrayEquals(foo, null));\n&gt;+\n&gt;+        // now check with same length, with same (foo2) and different (bar2)\n&gt;+        // contents\n&gt;+        assertFalse(&quot;different lengths&quot;, ArchiveUtils.byteArrayEquals(foo, bar));\n&gt;+\n&gt;+        assertTrue(&quot;same to itself&quot;, ArchiveUtils.byteArrayEquals(foo, foo));\n&gt;+        assertTrue(&quot;same contents&quot;, ArchiveUtils.byteArrayEquals(foo, foo2));\n&gt;+        assertFalse(&quot;different contents&quot;, ArchiveUtils.byteArrayEquals(foo, bar2));\n&gt;+    }\n&gt;+\n&gt;+    /*\n&gt;+     * helper methods\n&gt;+     */\n&gt;+\n&gt;+    /** check that this is a bad date, and &lt;code&gt;fail()&lt;/code&gt; if so.\n&gt;+     *\n&gt;+     * @param date the 12digit date to check\n&gt;+     */\n&gt;+    private void assertBad12DigitDate(final String date) {\n&gt;+        try {\n&gt;+            ArchiveUtils.parse12DigitDate(date);\n&gt;+        } catch (ParseException e) {\n&gt;+            return;\n&gt;+        }\n&gt;+        fail(&quot;Expected exception on parse of : &quot; + date);\n&gt;+\n&gt;+    }\n&gt;+    /**\n&gt;+     * check that this is a bad date, and &lt;code&gt;fail()&lt;/code&gt; if so.\n&gt;+     *\n&gt;+     * @param date the 14digit date to check\n&gt;+     */\n&gt;+    private void assertBad14DigitDate(final String date) {\n&gt;+        try {\n&gt;+            ArchiveUtils.parse14DigitDate(date);\n&gt;+        } catch (ParseException e) {\n&gt;+            return;\n&gt;+        }\n&gt;+        fail(&quot;Expected exception on parse of : &quot; + date);\n&gt;+\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * check that this is a bad date, and &lt;code&gt;fail()&lt;/code&gt; if so.\n&gt;+     *\n&gt;+     * @param date the 17digit date to check\n&gt;+     */\n&gt;+    private void assertBad17DigitDate(final String date) {\n&gt;+        try {\n&gt;+            ArchiveUtils.parse17DigitDate(date);\n&gt;+        } catch (ParseException e) {\n&gt;+            return;\n&gt;+        }\n&gt;+        fail(&quot;Expected exception on parse of : &quot; + date);\n&gt;+\n&gt;+    }\n&gt;+\n&gt;+    /** check that two longs are within a given &lt;code&gt;delta&lt;/code&gt; */\n&gt;+    private void assertClose(String desc, long date1, long date2, long delta) {\n&gt;+        assertTrue(desc, date1 == date2 ||\n&gt;+                    (date1 &lt; date2 && date2 &lt; (date1 + delta)) ||\n&gt;+                    (date2 &lt; date1 && date1 &lt; (date2 + delta)));\n&gt;+    }\n&gt;+}\n&gt;+\n&gt;Index: src/java/org/archive/util/DiskBackedQueueTest.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/DiskBackedQueueTest.java\n&gt;diff -N src/java/org/archive/util/DiskBackedQueueTest.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/DiskBackedQueueTest.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -0,0 +1,78 @@\n&gt;+/* Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ * \n&gt;+ * File: DiskBackedQueueTest.java\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.Test;\n&gt;+import junit.framework.TestCase;\n&gt;+import junit.framework.TestSuite;\n&gt;+\n&gt;+import java.io.File;\n&gt;+import java.io.IOException;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for DiskBackedQueue\n&gt;+ * \n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+public class DiskBackedQueueTest extends QueueTestBase {\n&gt;+    /**\n&gt;+     * Create a new DiskBackedQueueTest object\n&gt;+     * \n&gt;+     * @param testName the name of the test\n&gt;+     */\n&gt;+    public DiskBackedQueueTest(final String testName) {\n&gt;+        super(testName);\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * run all the tests for DiskBackedQueueTest\n&gt;+     * \n&gt;+     * @param argv the command line arguments\n&gt;+     */\n&gt;+    public static void main(String argv[]) {\n&gt;+        junit.textui.TestRunner.run(suite());\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * return the suite of tests for DiskBackedQueueTest\n&gt;+     * \n&gt;+     * @return the suite of test\n&gt;+     */\n&gt;+    public static Test suite() {\n&gt;+        return new TestSuite(DiskBackedQueueTest.class);\n&gt;+    }\n&gt;+\n&gt;+    \n&gt;+    protected Queue makeQueue() {\n&gt;+        try {\n&gt;+            return new DiskBackedQueue(new File(&quot;/tmp&quot;), &quot;foo&quot;, 10);\n&gt;+        } catch (final IOException e) {\n&gt;+            fail(&quot;Caught IO Exception on creation of queue : &quot; + e.getMessage());\n&gt;+            // never gets here\n&gt;+            return null;\n&gt;+        }\n&gt;+    }\n&gt;+\n&gt;+    // TODO - implement test methods in DiskBackedQueueTest\n&gt;+}\n&gt;+\n&gt;Index: src/java/org/archive/util/DiskQueue.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/DiskQueue.java,v\n&gt;retrieving revision 1.2\n&gt;diff -u -u -r1.2 DiskQueue.java\n&gt;--- src/java/org/archive/util/DiskQueue.java\t3 Jan 2004 01:16:46 -0000\t1.2\n&gt;+++ src/java/org/archive/util/DiskQueue.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -44,37 +44,59 @@\n&gt;  * pull out excessive referenced objects, or objects which\n&gt;  * will be redundantly reinstantiated upon dequeue() from \n&gt;  * disk. \n&gt;- * \n&gt;+ *\n&gt;+ * This class is not syncronized internally.\n&gt;+ *\n&gt;  * @author Gordon Mohr\n&gt;  */\n&gt; public class DiskQueue implements Queue {\n&gt; \tprivate static Logger logger = Logger.getLogger(&quot;org.archive.util.DiskQueue&quot;);\n&gt; \n&gt;+    /** the directory used to create the temporary files */\n&gt; \tprivate File scratchDir;\n&gt;-\tString name;\n&gt;+\n&gt;+    /** the prefix for the files created in the scratchDir */\n&gt;+\tString prefix;\n&gt;+\n&gt;+    /** the number of elements currently in the queue */\n&gt; \tlong length;\n&gt;+\n&gt;+    /** the object which deals with serializing the actual bytes to/from disk */\n&gt; \tDiskBackedByteQueue bytes;\n&gt;+\n&gt; \tObjectOutputStream testStream; // to verify that object is serializable\n&gt; \tObjectOutputStream tailStream;\n&gt; \tObjectInputStream headStream;\n&gt;-\t\n&gt;-\t/**\n&gt;-\t * @param dir\n&gt;-\t * @param name\n&gt;-\t * \n&gt;-\t */\n&gt;-\tpublic DiskQueue(File dir, String name) {\n&gt;-\t\tlength = 0;\n&gt;-\t\tthis.name = name;\n&gt;+\n&gt;+    /** a flag which marks when the lazy initialization is finished, and the\n&gt;+     * object is ready for use\n&gt;+     */\n&gt;+\tprivate boolean isInitialized = false;\n&gt;+\n&gt;+\t/** Create a new {@link DiskQueue} which creates its temporary files in a\n&gt;+     * given directory, with a given prefix.\n&gt;+     *\n&gt;+\t * @param dir the directory in which to create the data files\n&gt;+\t * @param prefix\n&gt;+\t * @throws FileNotFoundException if we cannot create an appropriate file\n&gt;+\t */\n&gt;+\tpublic DiskQueue(File dir, String prefix) throws FileNotFoundException {\n&gt;+\t\tif(dir == null || prefix == null) {\n&gt;+            throw new FileNotFoundException(&quot;null arguments not accepted&quot;);\n&gt;+        }\n&gt;+        \n&gt;+        length = 0;\n&gt;+\t\tthis.prefix = prefix;\n&gt; \t\tthis.scratchDir = dir;\n&gt;+        bytes = new DiskBackedByteQueue(scratchDir, this.prefix);\n&gt; \t\t// TODO someday: enable queue to already be filled\n&gt; \t}\n&gt; \t\n&gt; \tprivate void lateInitialize() throws FileNotFoundException, IOException {\n&gt;-\t\tbytes = new DiskBackedByteQueue(scratchDir,this.name);\n&gt; \t\ttestStream = new ObjectOutputStream(new NullOutputStream());\n&gt; \t\ttailStream = new ObjectOutputStream(bytes.getTailStream());\n&gt; \t\theadStream = new ObjectInputStream(bytes.getHeadStream());\n&gt;+        isInitialized = true;\n&gt; \t}\n&gt; \n&gt; \t/* (non-Javadoc)\n&gt;@@ -83,7 +105,7 @@\n&gt; \tpublic void enqueue(Object o){\n&gt; \t\t//logger.finest(name+&quot;(&quot;+length+&quot;): &quot;+o);\n&gt; \t\ttry {\n&gt;-\t\t\tif(bytes==null) {\n&gt;+\t\t\tif(!isInitialized) {\n&gt; \t\t\t\tlateInitialize();\n&gt; \t\t\t}\n&gt; \t\t\t// TODO: optimize this, for example by serializing to buffer, then writing to disk on success\n&gt;@@ -140,10 +162,9 @@\n&gt; \tpublic void release() {\n&gt; \t\tif (bytes != null) {\n&gt; \t\t\ttry {\n&gt;-\t\t\t\theadStream.close();\n&gt;-\t\t\t\ttailStream.close();\n&gt;+\t\t\t\tif(headStream != null) headStream.close();\n&gt;+\t\t\t\tif(tailStream != null) tailStream.close();\n&gt; \t\t\t\tbytes.discard();\n&gt;-\n&gt; \t\t\t} catch (IOException e) {\n&gt; \t\t\t\t// TODO: convert to runtime? \n&gt; \t\t\t\te.printStackTrace();\n&gt;Index: src/java/org/archive/util/DiskQueueTest.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/DiskQueueTest.java\n&gt;diff -N src/java/org/archive/util/DiskQueueTest.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/DiskQueueTest.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -0,0 +1,119 @@\n&gt;+/* Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ * \n&gt;+ * File: DiskQueueTest.java\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.Test;\n&gt;+import junit.framework.TestCase;\n&gt;+import junit.framework.TestSuite;\n&gt;+\n&gt;+import java.io.File;\n&gt;+import java.io.FileNotFoundException;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for DiskQueue\n&gt;+ * \n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+public class DiskQueueTest extends QueueTestBase {\n&gt;+    private static final String FILE_PREFIX = &quot;foo&quot;;\n&gt;+\n&gt;+    private static final File FILE_TMPDIR = new File(&quot;/tmp&quot;);\n&gt;+\n&gt;+    /**\n&gt;+     * Create a new DiskQueueTest object\n&gt;+     * \n&gt;+     * @param testName the name of the test\n&gt;+     */\n&gt;+    public DiskQueueTest(final String testName) {\n&gt;+        super(testName);\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * run all the tests for DiskQueueTest\n&gt;+     * \n&gt;+     * @param argv the command line arguments\n&gt;+     */\n&gt;+    public static void main(String argv[]) {\n&gt;+        junit.textui.TestRunner.run(suite());\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * return the suite of tests for DiskQueueTest\n&gt;+     * \n&gt;+     * @return the suite of test\n&gt;+     */\n&gt;+    public static Test suite() {\n&gt;+        return new TestSuite(DiskQueueTest.class);\n&gt;+    }\n&gt;+\n&gt;+    /** make a new DiskQueue, using &lt;code&gt;/tmp&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt;\n&gt;+     * as the &lt;code&gt;scratchDir&lt;/code&gt; and &lt;code&gt;prefix&lt;/code&gt; respectively.\n&gt;+     * @return the Queue\n&gt;+     */\n&gt;+    protected Queue makeQueue() {\n&gt;+        try {\n&gt;+            return new DiskQueue(FILE_TMPDIR, FILE_PREFIX);\n&gt;+        } catch (FileNotFoundException e) {\n&gt;+            fail(&quot;file not found : &quot; + e.getMessage());\n&gt;+            // never gets here\n&gt;+            return null;\n&gt;+        }\n&gt;+    }\n&gt;+\n&gt;+    /*\n&gt;+     * DiskQueue specific tests\n&gt;+     */\n&gt;+\n&gt;+    /** test the creation of a queue using a non-existent dir */\n&gt;+    public void testCtorBadDir() {\n&gt;+         try {\n&gt;+            DiskQueue queue = new DiskQueue(new File(&quot;/foo&quot;), &quot;bar&quot;);\n&gt;+        } catch(FileNotFoundException e) {\n&gt;+            return;\n&gt;+        }\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * test the creation of a queue using a &lt;code&gt;null&lt;/code&gt; dir\n&gt;+     */\n&gt;+    public void testCtorNullDir() {\n&gt;+        try {\n&gt;+            DiskQueue queue = new DiskQueue(null, &quot;bar&quot;);\n&gt;+        } catch (FileNotFoundException e) {\n&gt;+            return;\n&gt;+        }\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * test the creation of a queue using a &lt;code&gt;null&lt;/code&gt; prefix\n&gt;+     */\n&gt;+    public void testCtorNullPrefix() {\n&gt;+        try {\n&gt;+            DiskQueue queue = new DiskQueue(null, &quot;bar&quot;);\n&gt;+        } catch (FileNotFoundException e) {\n&gt;+            return;\n&gt;+        }\n&gt;+    }\n&gt;+}\n&gt;+\n&gt;+\n&gt;Index: src/java/org/archive/util/MemQueue.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/MemQueue.java,v\n&gt;retrieving revision 1.1\n&gt;diff -u -u -r1.1 MemQueue.java\n&gt;--- src/java/org/archive/util/MemQueue.java\t23 Dec 2003 23:32:02 -0000\t1.1\n&gt;+++ src/java/org/archive/util/MemQueue.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -25,12 +25,21 @@\n&gt; \n&gt; import java.util.LinkedList;\n&gt; \n&gt;-/**\n&gt;+/** An im-memory implementation of a {@link Queue}.\n&gt;+ * \n&gt;  * @author gojomo\n&gt;  *\n&gt;  */\n&gt; public class MemQueue extends LinkedList implements Queue {\n&gt;+    /** Create a new, empty MemQueue\n&gt;+     */\n&gt;+    public MemQueue() {\n&gt;+        super();\n&gt;+    }\n&gt;+    /* (non-javadoc)\n&gt;+     * @see org.archive.util.Queue#enqueue()\n&gt; \n&gt;+     */\n&gt; \tpublic void enqueue(Object o) {\n&gt; \t\tadd(o);\n&gt; \t}\n&gt;Index: src/java/org/archive/util/MemQueueTest.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/MemQueueTest.java\n&gt;diff -N src/java/org/archive/util/MemQueueTest.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/MemQueueTest.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -0,0 +1,71 @@\n&gt;+/* Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ * \n&gt;+ * File: MemQueueTest.java\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.Test;\n&gt;+import junit.framework.TestCase;\n&gt;+import junit.framework.TestSuite;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for MemQueue\n&gt;+ * \n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+public class MemQueueTest extends QueueTestBase {\n&gt;+    /**\n&gt;+     * Create a new MemQueueTest object\n&gt;+     * \n&gt;+     * @param testName the name of the test\n&gt;+     */\n&gt;+    public MemQueueTest(final String testName) {\n&gt;+        super(testName);\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * run all the tests for MemQueueTest\n&gt;+     * \n&gt;+     * @param argv the command line arguments\n&gt;+     */\n&gt;+    public static void main(String argv[]) {\n&gt;+        junit.textui.TestRunner.run(suite());\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * return the suite of tests for MemQueueTest\n&gt;+     * \n&gt;+     * @return the suite of test\n&gt;+     */\n&gt;+    public static Test suite() {\n&gt;+        return new TestSuite(MemQueueTest.class);\n&gt;+    }\n&gt;+\n&gt;+    /*\n&gt;+     * test methods\n&gt;+     */\n&gt;+    protected Queue makeQueue() {\n&gt;+        return new MemQueue();\n&gt;+    }\n&gt;+\n&gt;+    // TODO - implement test methods in MemQueueTest\n&gt;+}\n&gt;+\n&gt;Index: src/java/org/archive/util/PaddingStringBuffer.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/PaddingStringBuffer.java,v\n&gt;retrieving revision 1.2\n&gt;diff -u -u -r1.2 PaddingStringBuffer.java\n&gt;--- src/java/org/archive/util/PaddingStringBuffer.java\t3 Jan 2004 01:16:46 -0000\t1.2\n&gt;+++ src/java/org/archive/util/PaddingStringBuffer.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -24,27 +24,30 @@\n&gt; package org.archive.util;\n&gt; \n&gt; /**\n&gt;- * StringBuffer-like utility which can add spaces to reach a certain column.\n&gt;- * \n&gt;+ * StringBuffer-like utility which can add spaces to reach a certain column.  It\n&gt;+ * allows you to append {@link String}, &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;s\n&gt;+ * to the buffer.\n&gt;+ *\n&gt;+ * Note: This class counts from 1, not 0.\n&gt;+ *\n&gt;  * Current use of String concatenation is awfully inefficient, should be\n&gt;- * changed at some point. \n&gt;- * \n&gt;+ * changed at some point.\n&gt;+ *\n&gt;  * @author Gordon Mohr\n&gt;  */\n&gt;-public class PaddingStringBuffer {\n&gt;+public final class PaddingStringBuffer {\n&gt; \t// TODO: be more efficient\n&gt; \tString buffer = &quot;&quot;;\n&gt; \t\n&gt;-\t/**\n&gt;+\t/** Create a new PaddingStringBuffer\n&gt; \t * \n&gt; \t */\n&gt; \tpublic PaddingStringBuffer() {\n&gt; \t\tsuper();\n&gt;-\t\t// TODO Auto-generated constructor stub\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;-\t * @param string\n&gt;+\t/** append a string directly to the buffer\n&gt;+\t * @param string the string to append\n&gt; \t * @return This wrapped buffer w/ the passed string appended.\n&gt; \t */\n&gt; \tpublic PaddingStringBuffer append(String string) {\n&gt;@@ -53,33 +56,36 @@\n&gt; \t}\n&gt; \t\n&gt; \t/**\n&gt;-\t * Append, right-aligned to the given column\n&gt;+\t * Append a string, right-aligned to the given columm.  If the buffer\n&gt;+     * length is already greater than the column specified, it simply appends\n&gt;+     * the string\n&gt; \t * \n&gt;-\t * @param col\n&gt;-\t * @param string\n&gt;+\t * @param col the column to right-align to\n&gt;+\t * @param string the string\n&gt; \t * @return This wrapped buffer w/ append string, right-aligned to the\n&gt;      * given column.\n&gt; \t */\n&gt; \tpublic PaddingStringBuffer raAppend(int col, String string) {\n&gt; \t\tpadTo(col-string.length());\n&gt; \t\tbuffer += string;\n&gt;-\t\treturn this; \n&gt;+\t\treturn this;\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;-\t * @param i\n&gt;-\t * @return This wrapped buffer w/ &#39;i&#39; spaces appended.\n&gt;+\t/** Pad to a given column.  If the buffer size is already greater than the\n&gt;+     * column, nothing is done.\n&gt;+\t * @param col\n&gt;+\t * @return The buffer padded to &lt;code&gt;i&lt;/code&gt;.\n&gt; \t */\n&gt;-\tpublic PaddingStringBuffer padTo(int i) {\n&gt;-\t\twhile(buffer.length()&lt;i) {\n&gt;+\tpublic PaddingStringBuffer padTo(int col) {\n&gt;+\t\twhile(buffer.length()&lt;col) {\n&gt; \t\t\tbuffer += &quot; &quot;;\n&gt; \t\t}\n&gt; \t\treturn this;\n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;-\t * @param i\n&gt;-\t * @return This wrapped buffer w/ &#39;i&#39; appended.\n&gt;+\t/** append an &lt;code&gt;int&lt;/code&gt; to the buffer.\n&gt;+\t * @param i the int to append\n&gt;+\t * @return This wrapped buffer with &lt;code&gt;i&lt;/code&gt; appended.\n&gt; \t */\n&gt; \tpublic PaddingStringBuffer append(int i) {\n&gt; \t\tbuffer += i;\n&gt;@@ -88,17 +94,21 @@\n&gt; \t\n&gt; \n&gt; \t/**\n&gt;-\t * @param col\n&gt;-\t * @param i\n&gt;-\t * @return This wrapped buffer w/ appended int, right-aligned to the\n&gt;-     * given column.\n&gt;-\t */\n&gt;+     * Append an &lt;code&gt;int&lt;/code&gt; right-aligned to the given column.  If the\n&gt;+     * buffer length is already greater than the column specified, it simply\n&gt;+     * appends the &lt;code&gt;int&lt;/code&gt;.\n&gt;+     *\n&gt;+     * @param col the column to right-align to\n&gt;+     * @param i   the int to append\n&gt;+     * @return This wrapped buffer w/ appended int, right-aligned to the\n&gt;+     *         given column.\n&gt;+     */\n&gt; \tpublic PaddingStringBuffer raAppend(int col, int i) {\n&gt; \t\treturn raAppend(col,Integer.toString(i)); \n&gt; \t}\n&gt; \n&gt;-\t/**\n&gt;-\t * @param lo\n&gt;+\t/** append a &lt;code&gt;long&lt;/code&gt; to the buffer.\n&gt;+\t * @param lo the &lt;code&gt;long&lt;/code&gt; to append\n&gt; \t * @return This wrapped buffer w/ appended long.\n&gt; \t */\n&gt; \tpublic PaddingStringBuffer append(long lo) {\n&gt;@@ -106,9 +116,11 @@\n&gt; \t\treturn this; \n&gt; \t}\n&gt; \t\n&gt;-\t/**\n&gt;-\t * @param col\n&gt;-\t * @param lo\n&gt;+\t/**Append a &lt;code&gt;long&lt;/code&gt;, right-aligned to the given column.  If the\n&gt;+     * buffer length is already greater than the column specified, it simply\n&gt;+     * appends the &lt;code&gt;long&lt;/code&gt;.\n&gt;+\t * @param col the column to right-align to\n&gt;+\t * @param lo the long to append\n&gt; \t * @return This wrapped buffer w/ appended long, right-aligned to the\n&gt;      * given column.\n&gt; \t */\n&gt;@@ -116,6 +128,10 @@\n&gt; \t\treturn raAppend(col,Long.toString(lo)); \n&gt; \t}\n&gt; \n&gt;+    /** reset the buffer back to empty */\n&gt;+    public void reset() {\n&gt;+        buffer = &quot;&quot;;\n&gt;+    }\n&gt; \n&gt; \t/* (non-Javadoc)\n&gt; \t * @see java.lang.Object#toString()\n&gt;Index: src/java/org/archive/util/PaddingStringBufferTest.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/PaddingStringBufferTest.java\n&gt;diff -N src/java/org/archive/util/PaddingStringBufferTest.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/PaddingStringBufferTest.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -0,0 +1,186 @@\n&gt;+/* Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ * \n&gt;+ * File: PaddingStringBufferTest.java\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.Test;\n&gt;+import junit.framework.TestCase;\n&gt;+import junit.framework.TestSuite;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for PaddingStringBuffer\n&gt;+ * \n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+public class PaddingStringBufferTest extends TestCase {\n&gt;+    /**\n&gt;+     * Create a new PaddingStringBufferTest object\n&gt;+     * \n&gt;+     * @param testName the name of the test\n&gt;+     */\n&gt;+    public PaddingStringBufferTest(final String testName) {\n&gt;+        super(testName);\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * run all the tests for PaddingStringBufferTest\n&gt;+     * \n&gt;+     * @param argv the command line arguments\n&gt;+     */\n&gt;+    public static void main(String argv[]) {\n&gt;+        junit.textui.TestRunner.run(suite());\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * return the suite of tests for PaddingStringBufferTest\n&gt;+     * \n&gt;+     * @return the suite of test\n&gt;+     */\n&gt;+    public static Test suite() {\n&gt;+        return new TestSuite(PaddingStringBufferTest.class);\n&gt;+    }\n&gt;+\n&gt;+    public void setUp() {\n&gt;+        buf = new PaddingStringBuffer();\n&gt;+    }\n&gt;+\n&gt;+    /** first check that padTo works ok, since all depends on it */\n&gt;+    public void testPadTo() {\n&gt;+        PaddingStringBuffer retBuf;\n&gt;+        assertEquals(&quot;nothing in buffer&quot;, &quot;&quot;, buf.toString());\n&gt;+        retBuf = buf.padTo(5);\n&gt;+        assertEquals(&quot;retBuf same as buf&quot;, retBuf, buf);\n&gt;+        assertEquals(&quot;5 spaces&quot;, &quot;     &quot;, buf.toString());\n&gt;+\n&gt;+        // now do a smaller value - nothing should happen\n&gt;+        buf.padTo(4);\n&gt;+        assertEquals(&quot;5 spaces&quot;, &quot;     &quot;, buf.toString());\n&gt;+\n&gt;+        // now pad tro a greater length\n&gt;+        buf.padTo(10);\n&gt;+        assertEquals(&quot;10 spaces&quot;, &quot;          &quot;, buf.toString());\n&gt;+    }\n&gt;+\n&gt;+    /** test that append(String) works correctly */\n&gt;+    public void testAppendString() {\n&gt;+        // a buf to hold the return buffer\n&gt;+        PaddingStringBuffer retBuf;\n&gt;+        assertEquals(&quot;nothing in buffer&quot;, &quot;&quot;, buf.toString());\n&gt;+        retBuf = buf.append(&quot;foo&quot;);\n&gt;+        assertEquals(&quot;foo in buffer&quot;, &quot;foo&quot;, buf.toString());\n&gt;+        assertEquals(&quot;retBuf good&quot;, retBuf.toString(), buf.toString());\n&gt;+        retBuf = buf.append(&quot;bar&quot;);\n&gt;+        assertEquals(&quot;foobar in buffer&quot;, &quot;foobar&quot;, buf.toString());\n&gt;+        assertEquals(&quot;retBuf good&quot;, retBuf.toString(), buf.toString());\n&gt;+    }\n&gt;+\n&gt;+    /** check the reset method clears the buffer */\n&gt;+    public void testReset() {\n&gt;+        // append something into the buffer\n&gt;+        assertEquals(&quot;nothing in buffer&quot;, &quot;&quot;, buf.toString());\n&gt;+        buf.append(&quot;foo&quot;);\n&gt;+        assertEquals(&quot;buffer is &#39;foo&#39;&quot;, &quot;foo&quot;, buf.toString());\n&gt;+        buf.reset();\n&gt;+        assertEquals(&quot;nothing in buffer after reset&quot;, &quot;&quot;, buf.toString());\n&gt;+    }\n&gt;+\n&gt;+    /** test the raAppend(String) works in the simple cases */\n&gt;+    public void testRaAppend() {\n&gt;+        // a buf to hold the return buffer\n&gt;+        PaddingStringBuffer retBuf;\n&gt;+        assertEquals(&quot;nothing in buffer&quot;, &quot;&quot;, buf.toString());\n&gt;+        retBuf = buf.raAppend(5, &quot;foo&quot;);\n&gt;+        assertEquals(&quot;foo in buffer&quot;, &quot;  foo&quot;, buf.toString());\n&gt;+        assertEquals(&quot;retBuf good&quot;, retBuf.toString(), buf.toString());\n&gt;+        retBuf = buf.raAppend(9, &quot;bar&quot;);\n&gt;+        assertEquals(&quot;foobar in buffer&quot;, &quot;  foo bar&quot;, buf.toString());\n&gt;+        assertEquals(&quot;retBuf good&quot;, retBuf.toString(), buf.toString());\n&gt;+\n&gt;+        // now check with out-of-range columns - should just append\n&gt;+        buf = new PaddingStringBuffer();\n&gt;+        buf.raAppend(-1, &quot;foo&quot;);\n&gt;+        assertEquals(&quot;no padding for -1&quot;, &quot;foo&quot;, buf.toString());\n&gt;+        buf = new PaddingStringBuffer();\n&gt;+        buf.raAppend(0, &quot;foo&quot;);\n&gt;+        assertEquals(&quot;no padding for 0&quot;, &quot;foo&quot;, buf.toString());\n&gt;+\n&gt;+    }\n&gt;+\n&gt;+    /** check what happens when we right append, but the string is longer\n&gt;+     * than the space */\n&gt;+    public void testRaAppendWithTooLongString() {\n&gt;+        buf.raAppend(3,&quot;foobar&quot;);\n&gt;+        assertEquals(&quot;no padding when padding col less than string length&quot;,\n&gt;+                &quot;foobar&quot;, buf.toString());\n&gt;+        buf.reset();\n&gt;+    }\n&gt;+\n&gt;+    /** check it all works with the length == the length of the string */\n&gt;+    public void testRaAppendWithExactLengthString() {\n&gt;+        buf.raAppend(6, &quot;foobar&quot;);\n&gt;+        buf.raAppend(12, &quot;foobar&quot;);\n&gt;+        assertEquals(&quot;no padding with exact length string&quot;,\n&gt;+                &quot;foobarfoobar&quot;, buf.toString());\n&gt;+    }\n&gt;+\n&gt;+    /** check that append(int) works */\n&gt;+    public void testAppendInt() {\n&gt;+        buf.append((int)1);\n&gt;+        assertEquals(&quot;buffer is &#39;1&#39;&quot;, &quot;1&quot;, buf.toString());\n&gt;+        buf.append((int)234);\n&gt;+        assertEquals(&quot;buffer is &#39;1234&#39;&quot;, &quot;1234&quot;, buf.toString());\n&gt;+    }\n&gt;+\n&gt;+    /** check that raAppend(int) works */\n&gt;+    public void testRaAppendInt() {\n&gt;+        // right-append &#39;1&#39; to column 5\n&gt;+        buf.raAppend(5, (int)1);\n&gt;+        assertEquals(&quot;buf is &#39;    1&#39;&quot;, &quot;    1&quot;, buf.toString());\n&gt;+        // try appending a too-long int\n&gt;+\n&gt;+        buf.raAppend(6,(int)123);\n&gt;+        assertEquals(&quot;&#39;123&#39; appended&quot;, &quot;    1123&quot;, buf.toString());\n&gt;+    }\n&gt;+\n&gt;+    /** check that  append(long) works */\n&gt;+    public void testAppendLong() {\n&gt;+        buf.append((long)1);\n&gt;+        assertEquals(&quot;buffer is &#39;1&#39;&quot;, &quot;1&quot;, buf.toString());\n&gt;+        buf.append((long)234);\n&gt;+        assertEquals(&quot;buffer is &#39;1234&#39;&quot;, &quot;1234&quot;, buf.toString());\n&gt;+    }\n&gt;+\n&gt;+    /** check that raAppend(long) works */\n&gt;+    public void testRaAppendLong() {\n&gt;+// right-append &#39;1&#39; to column 5\n&gt;+        buf.raAppend(5, (long) 1);\n&gt;+        assertEquals(&quot;buf is &#39;    1&#39;&quot;, &quot;    1&quot;, buf.toString());\n&gt;+        // try appending a too-long int\n&gt;+\n&gt;+        buf.raAppend(6, (long) 123);\n&gt;+        assertEquals(&quot;&#39;123&#39; appended&quot;, &quot;    1123&quot;, buf.toString());\n&gt;+    }\n&gt;+\n&gt;+    /** a temp buffer for testing with */\n&gt;+    private PaddingStringBuffer buf;\n&gt;+}\n&gt;+\n&gt;Index: src/java/org/archive/util/Queue.java\n&gt;===================================================================\n&gt;RCS file: /cvsroot/archive-crawler/ArchiveOpenCrawler/src/java/org/archive/util/Queue.java,v\n&gt;retrieving revision 1.2\n&gt;diff -u -u -r1.2 Queue.java\n&gt;--- src/java/org/archive/util/Queue.java\t3 Jan 2004 01:16:46 -0000\t1.2\n&gt;+++ src/java/org/archive/util/Queue.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -23,22 +23,37 @@\n&gt;  */\n&gt; package org.archive.util;\n&gt; \n&gt;+import java.util.NoSuchElementException;\n&gt; \n&gt;-/**\n&gt;+\n&gt;+/** An Abstract queue.  It should implement FIFO semantics.\n&gt;  * @author gojomo\n&gt;  *\n&gt;  */\n&gt; public interface Queue {\n&gt; \n&gt;-\t/**\n&gt;-\t * @param o\n&gt;+\t/** Add an entry to the end of queue\n&gt;+\t * @param o the entry to queue\n&gt; \t */\n&gt; \tvoid enqueue(Object o);\n&gt; \n&gt;+    /** is the queue empty?\n&gt;+     *\n&gt;+     * @return &lt;code&gt;true&lt;/code&gt; if the queue has no elements\n&gt;+     */\n&gt; \tboolean isEmpty();\n&gt; \n&gt;-\tObject dequeue();\n&gt;+    /** remove an entry from the start of the  queue\n&gt;+     *\n&gt;+     * @return the object\n&gt;+     * @throws java.util.NoSuchElementException\n&gt;+     */\n&gt;+\tObject dequeue() throws NoSuchElementException;\n&gt; \n&gt;+    /** get the number of elements in the queue\n&gt;+     *\n&gt;+     * @return the number of elements in the queue\n&gt;+     */\n&gt; \tlong length();\n&gt; \n&gt; \t/**\n&gt;Index: src/java/org/archive/util/QueueTestBase.java\n&gt;===================================================================\n&gt;RCS file: src/java/org/archive/util/QueueTestBase.java\n&gt;diff -N src/java/org/archive/util/QueueTestBase.java\n&gt;--- /dev/null\t1 Jan 1970 00:00:00 -0000\n&gt;+++ src/java/org/archive/util/QueueTestBase.java\t19 Jan 2004 12:45:40 -0000\n&gt;@@ -0,0 +1,132 @@\n&gt;+/* Copyright (C) 2004 Internet Archive.\n&gt;+ *\n&gt;+ * This file is part of the Heritrix web crawler (crawler.archive.org).\n&gt;+ *\n&gt;+ * Heritrix is free software; you can redistribute it and/or modify\n&gt;+ * it under the terms of the GNU Lesser Public License as published by\n&gt;+ * the Free Software Foundation; either version 2.1 of the License, or\n&gt;+ * any later version.\n&gt;+ *\n&gt;+ * Heritrix is distributed in the hope that it will be useful,\n&gt;+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n&gt;+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n&gt;+ * GNU Lesser Public License for more details.\n&gt;+ *\n&gt;+ * You should have received a copy of the GNU Lesser Public License\n&gt;+ * along with Heritrix; if not, write to the Free Software\n&gt;+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n&gt;+ *\n&gt;+ * QueueTestBase.java\n&gt;+ *\n&gt;+ * $Header: $\n&gt;+ */\n&gt;+\n&gt;+package org.archive.util;\n&gt;+\n&gt;+import junit.framework.TestCase;\n&gt;+import junit.framework.Test;\n&gt;+import junit.framework.TestSuite;\n&gt;+\n&gt;+import java.util.NoSuchElementException;\n&gt;+\n&gt;+/**\n&gt;+ * JUnit test suite for Queue.  It&#39;s an abstract class which is implemented by\n&gt;+ * each queue implementation\n&gt;+ *\n&gt;+ * @author &lt;a href=&quot;mailto:me@...&quot;&gt;James Casey&lt;/a&gt;\n&gt;+ * @version $ Id:$\n&gt;+ */\n&gt;+public abstract class QueueTestBase extends TestCase {\n&gt;+    /**\n&gt;+     * Create a new PaddingStringBufferTest object\n&gt;+     *\n&gt;+     * @param testName the name of the test\n&gt;+     */\n&gt;+    public QueueTestBase(final String testName) {\n&gt;+        super(testName);\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * run all the tests for PaddingStringBufferTest\n&gt;+     *\n&gt;+     * @param argv the command line arguments\n&gt;+     */\n&gt;+    public static void main(String argv[]) {\n&gt;+        junit.textui.TestRunner.run(suite());\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * return the suite of tests for PaddingStringBufferTest\n&gt;+     *\n&gt;+     * @return the suite of test\n&gt;+     */\n&gt;+    public static Test suite() {\n&gt;+        return new TestSuite(PaddingStringBufferTest.class);\n&gt;+    }\n&gt;+\n&gt;+    public void setUp() {\n&gt;+        queue = makeQueue();\n&gt;+    }\n&gt;+\n&gt;+    public void tearDown() {\n&gt;+        if(queue != null) {\n&gt;+            queue.release();\n&gt;+        }\n&gt;+    }\n&gt;+\n&gt;+    /**\n&gt;+     * The abstract subclass constructor.  The subclass should create an\n&gt;+     * instance of the object it wishes to have tested\n&gt;+     *\n&gt;+     * @return the Queue object to be tested\n&gt;+     */\n&gt;+    protected abstract Queue makeQueue();\n&gt;+\n&gt;+    /*\n&gt;+     * test methods\n&gt;+     */\n&gt;+\n&gt;+    /** test that queue puts things on, and they stay there :) */\n&gt;+    public void testQueue() {\n&gt;+        assertEquals(&quot;no items in new queue&quot;, 0, queue.length());\n&gt;+        assertTrue(&quot;queue is empty&quot;, queue.isEmpty());\n&gt;+        queue.enqueue(&quot;foo&quot;);\n&gt;+        assertEquals(&quot;now one item in queue&quot;, 1, queue.length());\n&gt;+        assertFalse(&quot;queue not empty&quot;, queue.isEmpty());\n&gt;+    }\n&gt;+\n&gt;+    /** test that dequeue works */\n&gt;+    public void testDequeue() {\n&gt;+        assertEquals(&quot;no items in new queue&quot;, 0, queue.length());\n&gt;+        assertTrue(&quot;queue is empty&quot;, queue.isEmpty());\n&gt;+        queue.enqueue(&quot;foo&quot;);\n&gt;+        queue.enqueue(&quot;bar&quot;);\n&gt;+        queue.enqueue(&quot;baz&quot;);\n&gt;+        assertEquals(&quot;now three items in queue&quot;, 3, queue.length());\n&gt;+        assertEquals(&quot;foo dequeued&quot;, &quot;foo&quot;, queue.dequeue());\n&gt;+        assertEquals(&quot;bar dequeued&quot;, &quot;bar&quot;, queue.dequeue());\n&gt;+        assertEquals(&quot;baz dequeued&quot;, &quot;baz&quot;, queue.dequeue());\n&gt;+\n&gt;+        assertEquals(&quot;no items in new queue&quot;, 0, queue.length());\n&gt;+        assertTrue(&quot;queue is empty&quot;, queue.isEmpty());\n&gt;+\n&gt;+    }\n&gt;+\n&gt;+    /** check what happens we dequeue on empty */\n&gt;+    public void testDequeueEmptyQueue() {\n&gt;+        assertTrue(&quot;queue is empty&quot;, queue.isEmpty());\n&gt;+\n&gt;+        try {\n&gt;+            queue.dequeue();\n&gt;+        } catch (NoSuchElementException e) {\n&gt;+            return;\n&gt;+        }\n&gt;+        fail(&quot;Expected a NoSuchElementException on dequeue of empty queue&quot;);\n&gt;+    }\n&gt;+    /*\n&gt;+     * member variables\n&gt;+     */\n&gt;+\n&gt;+    /** the queue object to be tested */\n&gt;+    private Queue queue;\n&gt;+}\n&gt;&#92; No newline at end of file\n&gt;  \n&gt;\n\n\n\n"}}