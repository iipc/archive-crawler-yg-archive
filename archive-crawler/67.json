{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":137285340,"authorName":"Gordon Mohr","from":"&quot;Gordon Mohr&quot; &lt;gojomo@...&gt;","profile":"gojomo","replyTo":"LIST","senderId":"1ffMsgAQ30Ri9NOX3PzmoHvE-DPO6p-jsyECLqrn-hSXIuNiQASpwBNMiE8sVAGeGx09XZOLql_bAWYUmyP4H0NH7tLCgBSKew","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Scheduler/Store/Selector (aka &quot;frontier&quot;) Design Notes","postDate":"1054249290","msgId":67,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDAyNzIwMWMzMjYzNiQ0ZmM5ZjFiMCQ0OGYwZWRkMUBXT1JLU1RBVElPTjIxPg=="},"prevInTopic":0,"nextInTopic":0,"prevInTime":65,"nextInTime":68,"topicId":67,"numMessagesInTopic":1,"msgSnippet":"I ve been hammering out the details of a basic scheduler/store/selector (SSS) implementation: one which does not yet use persistent disk for large crawls or","rawEmail":"Return-Path: &lt;gojomo@...&gt;\r\nX-Sender: gojomo@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 79424 invoked from network); 29 May 2003 23:02:17 -0000\r\nReceived: from unknown (66.218.66.216)\n  by m2.grp.scd.yahoo.com with QMQP; 29 May 2003 23:02:17 -0000\r\nReceived: from unknown (HELO mail.archive.org) (209.237.232.56)\n  by mta1.grp.scd.yahoo.com with SMTP; 29 May 2003 23:02:15 -0000\r\nReceived: from WORKSTATION21 (b116-dyn-72.archive.org [209.237.240.72])\n\tby iahost-232-56.archive.org (8.12.8/8.10.2) with SMTP id h4TMEqlQ007722\n\tfor &lt;archive-crawler@yahoogroups.com&gt;; Thu, 29 May 2003 15:15:07 -0700\r\nMessage-ID: &lt;027201c32636$4fc9f1b0$48f0edd1@WORKSTATION21&gt;\r\nTo: &lt;archive-crawler@yahoogroups.com&gt;\r\nSubject: Scheduler/Store/Selector (aka &quot;frontier&quot;) Design Notes\r\nDate: Thu, 29 May 2003 16:01:30 -0700\r\nMIME-Version: 1.0\r\nContent-Type: text/plain;\n\tcharset=&quot;Windows-1252&quot;\r\nContent-Transfer-Encoding: 7bit\r\nX-Priority: 3\r\nX-MSMail-Priority: Normal\r\nX-Mailer: Microsoft Outlook Express 6.00.2800.1158\r\nX-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1165\r\nFrom: &quot;Gordon Mohr&quot; &lt;gojomo@...&gt;\r\nX-Yahoo-Group-Post: member; u=137285340\r\nX-Yahoo-Profile: gojomo\r\n\r\nI&#39;ve been hammering out the details of a basic scheduler/store/selector\n(SSS) implementation: one which does not yet use persistent disk for \nlarge crawls or checkpointing, but still handles the familiar \nconstraints on crawl-ordering, such as:\n  \n   - only one URI &quot;per host&quot; in process at a time\n   - some URIs deferred until after other prerequisites\n     (&quot;dns:*&quot;, &quot;*/robots.txt&quot;, perhaps others) have \n     completed\n   - some hosts off-limits for short periods of time\n     (for throttling/politeness)\n   - errored URIs retried only after some specific\n     period of time\n\nFlowing from the overall design, I&#39;m still aiming that:\n\n   - the URIScheduler and URISelector be as stateless as\n     possible, using URIStore for all their state\n   - actual politeness and prerequisite decisions made\n     by Processor modules, but then communicated back\n     to the SSS, so that pending URIs don&#39;t collect in the \n     Processor modules, instead in general-purpose \n     structures in the SSS\n\nThat second part is especially hard: unavoidably the\nSSS encodes many assumptions about what kinds of \nordering/delaying policies are desirable and possible. \nStill, I think such separation is a worthwhile goal, \nsince it should save outside contributors/extenders from \nhaving to delve into what will, in the SSS, likely be \nsome of the most complex and hard-to-easily-characterize\ncode.\n\nI think the following approach will meet the needs for \n&quot;Architectural Milestone #1&quot; (framework demo with\nin-memory dynamic state):\n\n__\nSimpleStore (an implementation of URIStore) data structures:\n\n - pendingQueue: all URIs for crawl consideration, in no particular\n   order. Might even include exact duplicates or equivalent-URIs.\n   For example, initially, all &quot;seeds&quot; are loaded here. \n\n   If at a loss for anything better to do with a URI, placing it at \n   the back of the pendingQueue should never cause problems beyond\n   the fact that it might not be revisited for a while: all &quot;proper&quot;\n   decisions about how it should be handled can be made when it\n   reaches the front of the pendingQueue.\n\n - readyClassQueues: a collection of &quot;classQueues&quot;. Each classQueue\n   collects URIs of a particular &quot;class&quot;. (Initially, the class is\n   the hostname or IP address, but this idea could be broadened in\n   the future.) The readyClassQueues collect all classQueues whose\n   head element may be dequeued to a ToeThread on request. \n\n - inProcessMap: a mapping of class keys to any &quot;in-process&quot; URIs (handed\n   out for processing but not yet returned). \n\n - heldClassQueues: a collection of &quot;classQueues&quot; where some other\n   URI of the same class is already &quot;in process&quot;, and so the rest\n   of the items in the queue are not eligible to be dequeued for \n   processing. \n\n - allClassQueuesMap: a mapping of class keys to the corresponding\n   classQueues. ClassQueues generally disappear when they are emptied.\n   An empty classQueue is only created when there is a need to \n   &quot;snooze&quot; a class for which there is no preexisting classQueue. \n\n - snoozedHeap: a heap of classQueues and individual URIs who\n   have been deferred to a specific time in the &quot;near&quot; future.\n   The earliest to become eligible for processing appear first. \n\n__\nSimpleScheduler (an implementation of URIScheduler) behavior,\nwhen asked by a ToeThread for a URI to process:\n\n - First, enter synchronized section\n\n - Then, update any time-triggered data structures:\n\n   while (snoozedHeap.head().isReady()) {\n     // place awoken (full) classQueues in readyQueue; place awoken URIs either \n     // atop the pendingQueue or somewhere TBD in a preexisting matching classQueue\n     fileToAppropriateStructure(snoozedHeap.dequeue());\n   }\n\n - Provide a URI from one of the readyClassQueues if possible:\n\n   if (readyClassQueues().hasElement()) {\n     return readyClassQueues().dequeueFromSubqueue();\n   }\n\n - Otherwise, try to get from pendingQueue:\n\n   while(pendingQueue.hasElement()) {\n     candidate = pendingQueue.dequeue();\n     if ( isRedundant(candidate) ) {\n        continue;\n     if (allClassQueues.hasKey(candidate.classKey()) {\n        // item must wait\n        allClassQueues.get(candidate.classKey).put(candidate);\n        continue;\n     }\n     // ok, candidate is not blocked\n     return candidate;\n   }\n\n - If pendingQueue exhausted...\n\n   if (heldClassQueues.empty() && snoozedHeap.empty()) {\n     noteCrawlFinished(); // at least until we support distant-future revisits\n     return null;\n   }\n\n - Otherwise, leave synchronized section and then:\n\n   // wait until either a notify comes or a snoozed item is ready to wake\n   readinessChangeSemaphore.wait(timeUntilFirstDesnooze());\n\n - Finally, start again from the top, until a returnable URI is found\n\n__\nSimpleSelector (an implementation of URISelector) behavior when\nhanded a processing-completed URI: \n\n - First, enter synchronized section\n\n - Then, decide where this processed URI (&#39;inCuri&#39;) goes:\n\n   if ( isFinishedDueToSuccessOrUnrecoverableError(inCuri) ) {\n      noteFinished(inCuri); // might be simply dropping out of all queues\n   } else if ( isErrorDeservingRetry(inCuri) ) {\n      // my place inCuri at head or tail of pendingQueue, or\n      // head or tail of classQueue, or at future spot in \n      // snoozedHeap\n      fileForRevisit(inCuri);\n   } else if ( isErrorPendingPreqrequisites(inCuri) ) {\n      pushToClassQueue(inCuri);\n   }\n\n- Handle discovered URIs, if present:\n\n  if ( inCuri.succeeded() && inCuri.hasDiscoveredURIs() {\n     foreach newURI in inCuri.discoveredURIs() {\n        if ( newURI.isInline() ) {\n            // to top of classQueue\n            fileForQuickVisit(newURI); // may do little or nothing if URI already seen\n        } else {\n            // to either bottom of classQueue (site-first)\n            // or somewhere in pendingQueue (breadth-first etc.)\n            fileForEventualVisit(newURI); // may do little or nothing if URI already seen\n        }\n     }\n  }\n\n- Handle any prerequisite(s), if present:\n\n  if (inCuri.hasPrerequisites()) {\n     foreach prereqURI in inCuri.prerequisites() {\n       // to top of classQueue\n       fileForImmediateVisit(prereqURI);\n     }\n  }\n\n- Handle other implications of inCuri&#39;s return:\n\n  if (inCuri.suggestsClassSnooze() ) {\n     snoozeQueue(classQueueFor(inCuri),inCuri.classSnoozeUntil());\n  } else {\n     // just make other URIs of inCuri&#39;s class ready for dequeueing\n     moveToReady(classQueueFor(inCuri));\n  }\n\n- Finally, exit synchronized section.\n\n__\nPotential future wrinkles of this approach: \n\n - Preferencing certain classQueues (eg strong site-first); \n - Sorting contents of individual classQueues\n - Providing URIs with override classes which cause them to be \n   fetched without regard to holds/snoozes. \n\n__\n\nComments & questions wanted.\n\n- Gordon\n\n"}}