{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":168599281,"authorName":"Michael Stack","from":"Michael Stack &lt;stack@...&gt;","profile":"stackarchiveorg","replyTo":"LIST","senderId":"KaNyw6Kp3HT-vrsJyPyfQV6UDQqg84PiDUrr1FE62ez8pmk3BAhPQb_iiwuOvDs6NK3SpKl52WQNj7AzlojFGZOiFJpteo5t","spamInfo":{"isSpam":false,"reason":"4"},"subject":"Re: [archive-crawler] ExtractorXML v2(beta) RFC","postDate":"1153758670","msgId":3121,"canDelete":false,"contentTrasformed":false,"systemMessage":true,"headers":{"messageIdInHeader":"PDQ0QzRGNUNFLjIwMTAxMDRAYXJjaGl2ZS5vcmc+","inReplyToHeader":"PGIxM2YzZjA2MDYwNzIwMTAxMm42N2Q2ZTc2MmdjZjU2YWIwMWU1NThlNWFmQG1haWwuZ21haWwuY29tPg==","referencesHeader":"PGIxM2YzZjA2MDYwNzIwMTAxMm42N2Q2ZTc2MmdjZjU2YWIwMWU1NThlNWFmQG1haWwuZ21haWwuY29tPg=="},"prevInTopic":3100,"nextInTopic":0,"prevInTime":3120,"nextInTime":3122,"topicId":3100,"numMessagesInTopic":2,"msgSnippet":"Good stuff Yousef. Would be sweet if based off mimetype, we ran one of the three extraction options: E.g. If likely ATOM feed, then we d run ATOM extraction;","rawEmail":"Return-Path: &lt;stack@...&gt;\r\nReceived: (qmail 25554 invoked from network); 27 Jul 2006 16:06:17 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m32.grp.scd.yahoo.com with QMQP; 27 Jul 2006 16:06:17 -0000\r\nReceived: from unknown (HELO n24.bullet.scd.yahoo.com) (66.94.237.53)\n  by mta2.grp.scd.yahoo.com with SMTP; 27 Jul 2006 16:06:17 -0000\r\nReceived: from [66.218.69.4] by n24.bullet.scd.yahoo.com with NNFMP; 27 Jul 2006 16:03:09 -0000\r\nReceived: from [66.218.66.90] by t4.bullet.scd.yahoo.com with NNFMP; 27 Jul 2006 16:03:09 -0000\r\nX-Sender: stack@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 61134 invoked from network); 24 Jul 2006 16:53:07 -0000\r\nReceived: from unknown (66.218.67.35)\n  by m21.grp.scd.yahoo.com with QMQP; 24 Jul 2006 16:53:07 -0000\r\nReceived: from unknown (HELO dns.duboce.net) (63.203.238.114)\n  by mta9.grp.scd.yahoo.com with SMTP; 24 Jul 2006 16:53:06 -0000\r\nReceived: from [192.168.1.106] ([192.168.1.106])\n\t(authenticated)\n\tby dns-eth1.duboce.net (8.10.2/8.10.2) with ESMTP id k6OFEGT29568;\n\tMon, 24 Jul 2006 08:14:16 -0700\r\nMessage-ID: &lt;44C4F5CE.2010104@...&gt;\r\nDate: Mon, 24 Jul 2006 09:31:10 -0700\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686 (x86_64); en-US; rv:1.8.0.4) Gecko/20060516 SeaMonkey/1.0.2\r\nMIME-Version: 1.0\r\nTo: archive-crawler@yahoogroups.com\r\nReferences: &lt;b13f3f060607201012n67d6e762gcf56ab01e558e5af@...&gt;\r\nIn-Reply-To: &lt;b13f3f060607201012n67d6e762gcf56ab01e558e5af@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: quoted-printable\r\nX-eGroups-Msg-Info: 2:4:8:0\r\nFrom: Michael Stack &lt;stack@...&gt;\r\nSubject: Re: [archive-crawler] ExtractorXML v2(beta) RFC\r\nX-Yahoo-Group-Post: member; u=168599281; y=13cN3QB2WDOWAPGIHj4XpZmEaRjBfNCl1zNVI2G2fmzO-KDj9JaY_6Ml\r\nX-Yahoo-Profile: stackarchiveorg\r\nX-Yahoo-Marked-Not-Spam: \r\nX-Yahoo-Newman-Property: groups-system\r\nX-eGroups-Approved-By: gojomo &lt;gojomo@...&gt; via web; 27 Jul 2006 16:03:09 -0000\r\n\r\nGood stuff Yousef.\n\nWould be sweet if based off mimetype, we ran one of the=\r\n three extraction \noptions: E.g. If likely ATOM feed, then we&#39;d run ATOM ex=\r\ntraction; if \nRSS, then the processRSS code; otherwise, if other XML schema=\r\n, run the \nregex. But since mimetypes and file-endings are unreliable, woul=\r\nd it \nmake sense reading in first few K of the document, running some analy=\r\nsis \nto figure the schema, and then based off findings, pass to one of the =\r\n\nthree applicable extractors?\n\nOn your patch:\n\n+ I&#39;d suggest that your note=\r\ns below on unreliable mimetypes and \nfile-endings should be added to the cl=\r\nass javadoc.\n+ You could make the default constructor private then you coul=\r\nd use it \nfrom your main and not have to delete it later.\n+ In #extract, do=\r\n the isHttpTransactionContentToProcess and mimetype \nchecks first.  If the =\r\ncuri is not http or not our mimetype, then the \ngetting of attributes is wa=\r\nsted cycles.\n+ Would be grand if using attributes, the operator could confi=\r\ngure the \nextractor to go from extracting a specific type all the ways up t=\r\no \ngeneral extracting of any curi deemed XML.  Rather than the attributes \n=\r\nbeing mutually exclusive, I could set the 3 attributes -- PARSE_RSS, \nPARSE=\r\n_ATOM, and PARSE_GENERIC -- all on to achieve the latter case.\n+ Regards yo=\r\nur &#39;Is expensive&#39; comment on line 184, can you pass \njavolution a Stream?  =\r\nIf it takes a String only, thats a problem.\n\nThanks,\nSt.Ack\n\n\nYousef Ourabi=\r\n wrote:\n&gt;\n&gt; Hello:\n&gt;\n&gt; I tweaked the ExtractorXML to use Javolution&#39;s XML P=\r\null Parser\n&gt; (javolution.org) for well defined syndication format&#39;s such as=\r\n Atom\n&gt; and RSS. There are three configuration options, process generic xml=\r\n\n&gt; (which uses the regex) (unchanged from the original ExtractorXML) ,\n&gt; an=\r\nd process RSS/ATOM which both use the XPP parser.\n&gt;\n&gt; Comments, suggestions=\r\n, or pointing out problems would all be\n&gt; appreciated. I&#39;ll be sending out =\r\nthe more final version with a unit\n&gt; test and a tweak of htmlextractor whic=\r\nh would allow quick testing.\n&gt;\n&gt; The current version isn&#39;t uber-final, but =\r\nmore or less working and a\n&gt; good point to get some feedback\n&gt;\n&gt; know probl=\r\nems:\n&gt; * MimeType checks are useless, the BBC rss feed&#39;s mime type is\n&gt; tex=\r\nt/html, Newegg&#39;s rss feed text/html; charset=3Diso-8859-1. Instead of\n&gt; the=\r\n &quot;application/xml+rss&quot; that would be expected. This was doubly\n&gt; problemati=\r\nc because I thought I could do tests around mime-types....oh\n&gt; well.\n&gt;\n&gt; * =\r\nDocument extension checks also seem dubious to me (*.rss || *.xml)\n&gt; as the=\r\n newegg RSS feed is created via an ASP.NET page (as an example)\n&gt; http://ww=\r\nw.newegg.com/Product/RSS.asp?Submit=3DRSSDailyDeals \n&gt; &lt;http://www.newegg.c=\r\nom/Product/RSS.asp?Submit=3DRSSDailyDeals&gt;\n&gt;\n&gt; * processAtom has only been =\r\ntested with some made up Atom xml, not in \n&gt; the wild.\n&gt;\n&gt; Best,\n&gt; Yousef\n&gt;=\r\n\n&gt; \n&gt; ---------------------------------------------------------------------=\r\n---\n&gt;\n&gt; package org.archive.crawler.extractor;\n&gt;\n&gt; import java.io.IOExcepti=\r\non;\n&gt; import java.io.StringReader;\n&gt; import java.util.logging.Logger;\n&gt; imp=\r\nort java.util.regex.Matcher;\n&gt;\n&gt; import javolution.xml.pull.XmlPullParserEx=\r\nception;\n&gt; import javolution.xml.pull.XmlPullParserImpl;\n&gt;\n&gt; import org.apa=\r\nche.commons.httpclient.URIException;\n&gt; import org.archive.crawler.datamodel=\r\n.CoreAttributeConstants;\n&gt; import org.archive.crawler.datamodel.CrawlURI;\n&gt;=\r\n import org.archive.crawler.framework.CrawlController;\n&gt; import org.archive=\r\n.crawler.settings.SimpleType;\n&gt; import org.archive.crawler.settings.Type;\n&gt;=\r\n import org.archive.io.ReplayCharSequence;\n&gt; import org.archive.util.TextUt=\r\nils;\n&gt;\n&gt; public class ExtractorXML extends Extractor implements\n&gt; \t\tCoreAtt=\r\nributeConstants {\n&gt;\n&gt; \tprivate static final long serialVersionUID =3D 77001=\r\n25684900462251L;\n&gt;\n&gt; \tprivate static Logger logger =3D Logger.getLogger(Ext=\r\nractorXML.class\n&gt; \t\t\t.getName());\n&gt; \t\n&gt;     static final String XML_URI_EXT=\r\nRACTOR =3D    \n&gt;         &quot;(?i)[&#92;&quot;&#92;&#39;&gt;]&#92;&#92;s*(http:[^&#92;&#92;s&#92;&quot;&#92;&#39;&lt;&gt;]+)&#92;&#92;s*[&#92;&quot;&#92;&#39;&lt;]&quot;; =\r\n\n&gt;         // GROUPS:\n&gt;         // (G1) URI\n&gt;\n&gt;     private long numberOfCU=\r\nRIsHandled =3D 0;\n&gt; \tprivate long numberOfLinksExtracted =3D 0;\n&gt; \t\n&gt; \tpriv=\r\nate boolean isXmlMimeType =3D false;\n&gt; \tprivate boolean isRssMimeType =3D f=\r\nalse;\n&gt; \tprivate boolean isAtomMimeType =3D false;\n&gt;\n&gt; \t// Javolution XML P=\r\narser, very fast\n&gt; \tprivate XmlPullParserImpl mySaxParser;\n&gt;\n&gt; \t// Syndicat=\r\nion format elements wtih links\n&gt; \tprivate static final CharSequence RSS_LIN=\r\nK =3D &quot;link&quot;;\n&gt; \tprivate static final CharSequence ATOM_URI =3D &quot;uri&quot;;\n&gt;\n&gt; =\r\n\t// Syndication format Attributes with links\n&gt; \tprivate static final CharSe=\r\nquence ATOM_LINK_ATTR =3D &quot;link&quot;;\n&gt; \tprivate static final CharSequence ATOM=\r\n_EDIT_ATTR =3D &quot;edit&quot;;\n&gt; \t\n&gt; \t// User Configurable Values\n&gt; \tpublic static =\r\nfinal String ATTR_PARSE_RSS_FOR_LINKS =3D &quot;parse-rss-for-links&quot;;\n&gt; \tpublic =\r\nstatic final String ATTR_PARSE_ATOM_FOR_LINKS =3D &quot;parse-atom-for-links&quot;;\n&gt;=\r\n \tpublic static final String ATTR_PARSE_GENERIC_XML_FOR_LINKS =3D &quot;parse-ge=\r\nneric-xml-for-links&quot;;\n&gt; \t\n&gt; \t// Remote Page MIME-TYPES\n&gt; \tprivate static fi=\r\nnal String GENERIC_XML_MIME_TYPE =3D &quot;application/xml&quot;;\n&gt; \tprivate static f=\r\ninal String GENERIC_XML_MIME_TYPE_LEGACY =3D &quot;text/xml&quot;;\n&gt; \tprivate static =\r\nfinal String ATOM_MIME_TYPE =3D &quot;application/atom+xml&quot;;\n&gt; \tprivate static f=\r\ninal String RSS_MIME_TYPE =3D &quot;application/rss+xml&quot;;\n&gt; \tprivate static fina=\r\nl String HTML_MIME_TYPE =3D &quot;text/html&quot;;\n&gt; \tprivate static final String HTM=\r\nL_WITH_CHARSET =3D &quot;text/html; charset=3Diso-8859-1&quot;;\n&gt; \tprivate static fin=\r\nal String PLAIN_MIME_TYPE =3D &quot;text/plain&quot;;\n&gt;\n&gt; \t// FOR TESTING ONLY DELETE=\r\n ME!!!\n&gt; \tpublic ExtractorXML() {\n&gt; \t\tthis(&quot;&quot;, &quot;&quot;);\n&gt; \t}\n&gt;\n&gt; \tpublic Extrac=\r\ntorXML(String name) {\n&gt; \t\tthis(name, &quot;Syndicated Feed Extractor. Extracts l=\r\ninks from RSS/ATOM.&quot;);\n&gt; \t}\n&gt;\n&gt; \tpublic ExtractorXML(String name, String de=\r\nscription) {\n&gt; \t\tsuper(name, description);\n&gt; \t\tType t =3D addElementToDefin=\r\nition(new SimpleType(\n&gt; \t\t\t\tATTR_PARSE_RSS_FOR_LINKS,\n&gt; \t\t\t\t&quot;If enabled, RS=\r\nS feeds will be processed to extract outbound &quot; +\n&gt; \t\t\t\t&quot;links&quot;, Boolean.TR=\r\nUE));\n&gt; \t\tt.setExpertSetting(true);\n&gt; \t\tt =3D addElementToDefinition(new Si=\r\nmpleType(ATTR_PARSE_ATOM_FOR_LINKS,\n&gt; \t\t\t\t&quot;If enabled, ATOM feeds will be p=\r\nrocessed to extract outbound &quot;\n&gt; \t\t\t\t\t\t+ &quot;links&quot;, Boolean.TRUE));\n&gt; \t\tt.set=\r\nExpertSetting(true);\n&gt; \t\tt =3D addElementToDefinition(new SimpleType(\n&gt; \t\t\t=\r\n\tATTR_PARSE_GENERIC_XML_FOR_LINKS,\n&gt; \t\t\t\t&quot;If enabled, generic xml will be p=\r\nrocessed to extract outbound &quot;\n&gt; \t\t\t\t\t\t+ &quot;links&quot;, Boolean.TRUE));\n&gt; \t\tt.set=\r\nExpertSetting(true);\n&gt;\n&gt; \t}\n&gt;\n&gt; \t// Initialze Javolution XML parser\n&gt; \tprot=\r\nected void initialTasks() {\n&gt; \t\tmySaxParser =3D new XmlPullParserImpl();\n&gt;\n=\r\n&gt; \t}\n&gt;\n&gt; \t// is finalTasks() always called after processing is done?\n&gt; \t// =\r\nremove references to mark for gc()\n&gt; \tprotected void finalTasks() {\n&gt; \t\tmyS=\r\naxParser =3D null;\n&gt; \t}\n&gt;\n&gt; \t// This is what get&#39;s called? Delegate to proc=\r\nessRss, processAtom\n&gt; \tprotected void extract(CrawlURI curi) {\n&gt; \t\tReplayCh=\r\narSequence cs =3D null;\n&gt;\n&gt; \t\tfinal boolean isParsingRss =3D ((Boolean) get=\r\nUncheckedAttribute(curi,\n&gt; \t\t\t\tATTR_PARSE_RSS_FOR_LINKS)).booleanValue();\n&gt;=\r\n\n&gt; \t\tfinal boolean isParsingAtom =3D ((Boolean) getUncheckedAttribute(curi,=\r\n\n&gt; \t\t\t\tATTR_PARSE_ATOM_FOR_LINKS)).booleanValue();\n&gt;\n&gt; \t\tfinal boolean isPa=\r\nrsingGenericXml =3D ((Boolean) getUncheckedAttribute(\n&gt; \t\t\t\tcuri, ATTR_PARS=\r\nE_GENERIC_XML_FOR_LINKS)).booleanValue();\n&gt;\n&gt; \t\tif (!isHttpTransactionConte=\r\nntToProcess(curi)) {\n&gt; \t\t\treturn;\n&gt; \t\t}\n&gt; \t\t\t\n&gt; \t\tString mimeType =3D curi.=\r\ngetContentType();\n&gt; \t\tboolean isValidMimeType =3D isValidMimeType(mimeType)=\r\n;\n&gt; \t\t\n&gt; \t\t// This replaces all the previous validity/correctness checks to=\r\n procede\n&gt; \t\t// And also sets mime type to determine appropriate processor\n=\r\n&gt; \t\tif (isValidMimeType =3D=3D false) {\n&gt; \t\t\treturn;\n&gt; \t\t}\n&gt; \t\t\t\t\n&gt; \t\tthis.=\r\nnumberOfCURIsHandled++;\n&gt; \t\t\n&gt; \t\ttry {\n&gt; \t\t\tcs =3D curi.getHttpRecorder().g=\r\netReplayCharSequence();\n&gt; \t\t} catch (IOException e) {\n&gt; \t\t\tlogger.severe(&quot;F=\r\nailed getting ReplayCharSequence: &quot;\n&gt; \t\t\t\t\t+ e.getMessage());\n&gt; \t\t}\n&gt; \t\tif =\r\n(cs =3D=3D null) {\n&gt; \t\t\tlogger.severe(&quot;Failed getting ReplayCharSequence: &quot;=\r\n\n&gt; \t\t\t\t\t+ curi.toString());\n&gt; \t\t\treturn;\n&gt; \t\t}\n&gt; \t\t\n&gt; \t\t// Processer is det=\r\nermined by mime-type and configuration\n&gt; \t\tif (isParsingGenericXml && isXml=\r\nMimeType) {\n&gt; \t\t\t\n&gt;\n&gt; \t\t\tthis.numberOfLinksExtracted +=3D processGenericXml=\r\n(curi, cs,\n&gt; \t\t\t\t\tgetController());\n&gt;\n&gt; \t\t\t\n&gt; \t\t} else if (isParsingRss && =\r\nisXmlMimeType) {\n&gt;\n&gt; \t\t\tthis.numberOfLinksExtracted +=3D processRSS(curi, c=\r\ns, \n&gt; \t\t\t\t\tgetController());\n&gt;\n&gt; \t\t} else if (isParsingAtom && isAtomMimeTy=\r\npe) {\n&gt; \t\t\tthis.numberOfLinksExtracted +=3D processATOM(curi, cs,\n&gt; \t\t\t\t\tge=\r\ntController());\n&gt; \t\t\tSystem.out.println(&quot;parsing generic atom&quot;);\n&gt; \t\t} \t\n&gt; =\r\n\t}\n&gt;\n&gt; \t/**\n&gt; \t * ProcessRSS feed This method is package visible to ease te=\r\nsting.\n&gt; \t * \n&gt; \t * @param curi\n&gt; \t *            CrawlURI we&#39;re processing.=\r\n\n&gt; \t * @param cs\n&gt; \t *            Sequence from underlying ReplayCharSequen=\r\nce. This is\n&gt; \t *            TRANSIENT data. Make a copy if you want the da=\r\nta to\n&gt; \t *            live outside of this extractors&#39; lifetime.\n&gt; \t *    =\r\n        \n&gt; \t * @return number of links found\n&gt; \t */\n&gt; \tpublic long processR=\r\nSS(CrawlURI curi, CharSequence cs,\n&gt; \t\t\tCrawlController controller) {\n&gt;\n&gt; \t=\r\n\tlong foundLinks =3D 0;\n&gt; \t\tCharSequence elementName;\n&gt; \t\tCharSequence rssL=\r\nink;\n&gt; \t\t\n&gt; \t\tmySaxParser.setInput(new StringReader(cs.toString())); // exp=\r\nensive?\n&gt;\n&gt; \t\ttry {\n&gt; \t\t\tfor (int elem =3D mySaxParser.getEventType(); \n&gt; \t=\r\n\t\t     \t elem !=3D XmlPullParserImpl.END_DOCUMENT; \n&gt; \t\t\t     \t elem =3D my=\r\nSaxParser.next()) {\n&gt; \t\t\t\t\n&gt; \t\t\t\tif (elem =3D=3D XmlPullParserImpl.START_TA=\r\nG) {\n&gt; \t\t\t\t\t\n&gt; \t\t\t\t\telementName =3D mySaxParser.getName();\n&gt; \t\t\t\t\t\n&gt; \t\t\t\t\ti=\r\nf (mySaxParser.next() =3D=3D XmlPullParserImpl.TEXT\n&gt; \t\t\t\t\t\t\t&& isSyndElemW=\r\nithLinks(elementName)) {\n&gt;\n&gt; \t\t\t\t\t\trssLink =3D mySaxParser.getText();\n&gt; \t\t\t=\r\n\t\t\tfoundLinks++;\n&gt;\n&gt; \t\t\t\t\t\ttry {\n&gt; \t\t\t\t\t\t\tcuri.createAndAddLink(rssLink.toS=\r\ntring(),\n&gt; \t\t\t\t\t\t\t\t\tLink.NAVLINK_MISC, Link.NAVLINK_HOP);\n&gt; \t\t\t\t\t\t} catch (=\r\nURIException e) {\n&gt; \t\t\t\t\t\t\tif (controller !=3D null) {\n&gt; \t\t\t\t\t\t\t\tcontroller=\r\n.logUriError(e, curi.getUURI(),\n&gt; \t\t\t\t\t\t\t\t\t\trssLink);\n&gt; \t\t\t\t\t\t\t} else {\n&gt; \t=\r\n\t\t\t\t\t\t\tlogger.info(curi + &quot;, &quot; + rssLink + &quot;: &quot;\n&gt; \t\t\t\t\t\t\t\t\t\t+ e.getMessage(=\r\n));\n&gt; \t\t\t\t\t\t\t}\n&gt; \t\t\t\t\t\t}\n&gt; \t\t\t\t\t}\n&gt; \t\t\t\t}\n&gt; \t\t\t}\n&gt;\n&gt; \t\t} catch (XmlPullPars=\r\nerException e) {\n&gt; \t\t\tlogger.severe(curi + &quot;, XmlPullParserException: &quot; + e=\r\n.getMessage());\n&gt; \t\t} catch (IOException e) {\n&gt; \t\t\tlogger.severe(curi + &quot;, =\r\nIOException: &quot; + e.getMessage());\n&gt; \t\t}\n&gt;\n&gt; \t\tmySaxParser.reset(); // Reset=\r\n internal state of parser\n&gt; \t\treturn foundLinks;\n&gt; \t}\n&gt;\n&gt; \t/**\n&gt; \t * \n&gt; \t *=\r\n @param curi\n&gt; \t * @param cs\n&gt; \t * @param controller\n&gt; \t * @return\n&gt; \t */\n&gt;=\r\n \tpublic long processATOM(CrawlURI curi, CharSequence cs,\n&gt; \t\t\tCrawlControl=\r\nler controller) {\n&gt; \t\t\n&gt; \t\tlong foundLinks =3D 0;\n&gt; \t\tint attributeCount =\r\n=3D 0;\n&gt; \t\tmySaxParser.setInput(new StringReader(cs.toString())); // expens=\r\nive?\n&gt; \t\t\n&gt; \t\tCharSequence attrName;\n&gt; \t\tCharSequence elementName;\n&gt; \t\tChar=\r\nSequence atomLink;\n&gt;\n&gt; \t\t\n&gt; \t\ttry {\n&gt; \t\t\tfor (int elem =3D mySaxParser.getE=\r\nventType(); \n&gt; \t\t\t\t\t elem !=3D XmlPullParserImpl.END_DOCUMENT; \n&gt; \t\t\t\t\t ele=\r\nm =3D mySaxParser.next()) {\n&gt; \t\t\t\t\n&gt; \t\t\t\tif (elem =3D=3D XmlPullParserImpl.=\r\nSTART_TAG) { \n&gt;\n&gt; \t\t\t\t\telementName =3D mySaxParser.getName();\n&gt; \t\t\t\t\tattrib=\r\nuteCount =3D mySaxParser.getAttributeCount();\n&gt;\n&gt; \t\n&gt; \t\t\t\t\t// Element link =\r\ncheck\n&gt; \t\t\t\t\tif (mySaxParser.next() =3D=3D XmlPullParserImpl.TEXT\n&gt; \t\t\t\t\t\t\t=\r\n&& isSyndElemWithLinks(elementName)) {\n&gt; \t\t\t\t\t\tatomLink =3D mySaxParser.get=\r\nText();\n&gt; \t\t\t\t\t\n&gt; \t\t\t\t\t\t\n&gt; \t\t\t\t\t\ttry {\n&gt; \t\t\t\t\t\t\tcuri.createAndAddLink(atomL=\r\nink.toString(),\n&gt; \t\t\t\t\t\t\t\t\tLink.NAVLINK_MISC, Link.NAVLINK_HOP);\n&gt; \t\t\t\t\t\t} =\r\ncatch (URIException e) {\n&gt; \t\t\t\t\t\t\tif (controller !=3D null) {\n&gt; \t\t\t\t\t\t\t\tcon=\r\ntroller.logUriError(e, curi.getUURI(),\n&gt; \t\t\t\t\t\t\t\t\t\tatomLink);\n&gt; \t\t\t\t\t\t\t} el=\r\nse {\n&gt; \t\t\t\t\t\t\t\tlogger.info(curi + &quot;, &quot; + atomLink + &quot;: &quot;\n&gt; \t\t\t\t\t\t\t\t\t\t+ e.ge=\r\ntMessage());\n&gt; \t\t\t\t\t\t\t}\n&gt; \t\t\t\t\t\t}\n&gt;\n&gt; \t\t\t\t\t}\n&gt; \t\t\t\t\t\n&gt; \t\t\t\t\t\n&gt; \t\t\t\t\t// Attr=\r\nibute link check\n&gt; \t\t\t\t\tif (isSyndAttributeWithLinks(elementName)\n&gt; \t\t\t\t\t\t\t=\r\n&& attributeCount &gt; -1) {\n&gt; \t\t\t\t\t\t\n&gt; \t\t\t\t\t\tfor (int i =3D 0; i &lt; attributeC=\r\nount; i++) {\n&gt; \t\t\t\t\t\t\tattrName =3D mySaxParser.getAttributeValue(i);\n&gt; \t\t\t\t=\r\n\t\t\tif (isSyndAttributeWithLinks(attrName)) {\n&gt;\n&gt; \t\t\t\t\t\t\t\ttry {\n&gt; \t\t\t\t\t\t\t\t\tc=\r\nuri.createAndAddLink(attrName.toString(),\n&gt; \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLink.NAVLINK_MIS=\r\nC,\n&gt; \t\t\t\t\t\t\t\t\t\t\t\t\t\t\tLink.NAVLINK_HOP);\n&gt; \t\t\t\t\t\t\t\t} catch (URIException e) {=\r\n\n&gt; \t\t\t\t\t\t\t\t\tif (controller !=3D null) {\n&gt; \t\t\t\t\t\t\t\t\t\tcontroller.logUriError(=\r\ne, curi\n&gt; \t\t\t\t\t\t\t\t\t\t\t\t.getUURI(), attrName);\n&gt; \t\t\t\t\t\t\t\t\t} else {\n&gt; \t\t\t\t\t\t\t\t=\r\n\t\tlogger.info(curi + &quot;, &quot; + attrName\n&gt; \t\t\t\t\t\t\t\t\t\t\t\t+ &quot;: &quot; + e.getMessage())=\r\n;\n&gt; \t\t\t\t\t\t\t\t\t}\n&gt; \t\t\t\t\t\t\t\t}\n&gt; \t\t\t\t\t\t\t}\n&gt; \t\t\t\t\t\t}\n&gt; \t\t\t\t\t}\n&gt; \t\t\t\t}\n&gt; \t\t\t}\n&gt; \t=\r\n\t} catch (XmlPullParserException e) {\n&gt; \t\t\tlogger.severe(curi + &quot;, XmlPullP=\r\narserException: &quot; + e.getMessage() );\n&gt; \t\t} catch (IOException e) {\n&gt; \t\t\tlo=\r\ngger.severe(curi + &quot;, IOException: &quot; + e.getMessage());\n&gt; \t\t}\n&gt;\n&gt; \t\tmySaxPa=\r\nrser.reset(); // Reset internal state of parser\n&gt; \t\treturn foundLinks;\n&gt; \t}=\r\n\n&gt;\n&gt; \tpublic static long processGenericXml(CrawlURI curi, CharSequence cs,\n=\r\n&gt; \t\t\tCrawlController controller) {\n&gt; \t\t long foundLinks =3D 0;\n&gt; \t        M=\r\natcher uris =3D null;\n&gt; \t        String xmlUri;\n&gt; \t        uris =3D TextUti=\r\nls.getMatcher(XML_URI_EXTRACTOR, cs);\n&gt; \t        while (uris.find()) {\n&gt; \t =\r\n           xmlUri =3D uris.group(1);\n&gt; \t            xmlUri =3D (String) Tex=\r\ntUtils.unescapeHtml(xmlUri);\n&gt; \t            foundLinks++;\n&gt; \t            tr=\r\ny {\n&gt; \t                // treat as speculative, as whether context really \n=\r\n&gt; \t                // intends to create a followable/fetchable URI is\n&gt; \t  =\r\n              // unknown\n&gt; \t                curi.createAndAddLink(xmlUri,Li=\r\nnk.SPECULATIVE_MISC,\n&gt; \t                        Link.SPECULATIVE_HOP);\n&gt; \t =\r\n           } catch (URIException e) {\n&gt; \t                // There may not b=\r\ne a controller (e.g. If we&#39;re being run\n&gt; \t                // by the extrac=\r\ntor tool).\n&gt; \t                if (controller !=3D null) {\n&gt; \t              =\r\n      controller.logUriError(e, curi.getUURI(), xmlUri);\n&gt; \t               =\r\n } else {\n&gt; \t                    logger.info(curi + &quot;, &quot; + xmlUri + &quot;: &quot; +\n=\r\n&gt; \t                        e.getMessage());\n&gt; \t                }\n&gt; \t       =\r\n     }\n&gt; \t        }\n&gt; \t        TextUtils.recycleMatcher(uris);\n&gt; \t        r=\r\neturn foundLinks;\n&gt; \t}\n&gt;\n&gt; \t\n&gt; \t\n&gt; \tpublic String report() {\n&gt;         Stri=\r\nngBuffer ret =3D new StringBuffer();\n&gt;         ret.append(&quot;Processor: org.a=\r\nrchive.crawler.extractor.ExtractorXML&#92;n&quot;);\n&gt;         ret.append(&quot;  Function=\r\n:          Link extraction on XML/RSS&#92;n&quot;);\n&gt;         ret.append(&quot;  CrawlURI=\r\ns handled: &quot; + numberOfCURIsHandled + &quot;&#92;n&quot;);\n&gt;         ret.append(&quot;  Links =\r\nextracted:   &quot; + numberOfLinksExtracted + &quot;&#92;n&#92;n&quot;);\n&gt;\n&gt;         return ret.t=\r\noString();\n&gt; \t}\n&gt;\n&gt; \t\n&gt; \t/**\n&gt; \t * \n&gt; \t * @param elem\n&gt; \t * @return true if=\r\n the specified element is one with outbound links\n&gt; \t */\n&gt; \tprivate boolean=\r\n isSyndElemWithLinks(CharSequence elem){\n&gt; \t\tboolean mightHaveLinks =3D fal=\r\nse;\n&gt; \t\t\n&gt; \t\tif (elem =3D=3D null) {\n&gt; \t\t\treturn mightHaveLinks;\n&gt; \t\t}\n&gt; \t\t=\r\n\n&gt; \t\tif (elem.equals(ATOM_URI)) {\n&gt; \t\t\tmightHaveLinks =3D true;\n&gt; \t\t} else =\r\nif (elem.equals(RSS_LINK)) {\n&gt; \t\t\tmightHaveLinks =3D true;\n&gt; \t\t} \n&gt; \t\t\n&gt; \t\t=\r\nreturn mightHaveLinks;\n&gt; \t}\n&gt; \t\n&gt; \t/**\n&gt; \t * \n&gt; \t * @param attr\n&gt; \t * @retu=\r\nrn true if the specified attribute is one with outbound links\n&gt; \t */\n&gt; \tpri=\r\nvate boolean isSyndAttributeWithLinks (CharSequence attr) {\n&gt; \t\tboolean mig=\r\nhtHaveLinks =3D false;\n&gt; \t\t\n&gt; \t\tif (attr =3D=3D null) {\n&gt; \t\t\treturn mightHa=\r\nveLinks;\n&gt; \t\t}\n&gt; \t\t\n&gt; \t\tif (attr.equals(ATOM_LINK_ATTR)) {\n&gt; \t\t\tmightHaveLi=\r\nnks =3D true;\n&gt; \t\t} else if (attr.equals(ATOM_EDIT_ATTR)) {\n&gt; \t\t\tmightHaveL=\r\ninks =3D true;\n&gt; \t\t}\n&gt; \t\t\n&gt; \t\treturn mightHaveLinks;\n&gt; \t}\n&gt; \t\n&gt; \t/**\n&gt; \t * =\r\n\n&gt; \t * // Possible tweaks to mime-type checks\n&gt; \t\tif ((mimeType.toLowerCase=\r\n().indexOf(&quot;xml&quot;) &lt; 0)\n&gt; \t\t\t\t&& (!curi.toString().toLowerCase().endsWith(&quot;.=\r\nrss&quot;))\n&gt; \t\t\t\t&& (!curi.toString().toLowerCase().endsWith(&quot;.atom&quot;))) {\n&gt;\n&gt; \t=\r\n\t\treturn;\n&gt; \t\t\n&gt; \t * \n&gt; \t * \n&gt; \t * @param mimeType\n&gt; \t * @return true if Ex=\r\ntractor should procede\n&gt; \t */\n&gt; \tprivate boolean isValidMimeType(String mim=\r\neType) {\n&gt; \t\tboolean isXmlMimeType =3D false;\n&gt; \t\t\n&gt; \t\t// Yousef DELETE ME!=\r\n!!\n&gt; \t\tSystem.out.println(&quot;MimeType is: &quot; + mimeType);\n&gt; \t\t\n&gt; \t\tif (mimeTyp=\r\ne =3D=3D null) {\n&gt; \t\t\treturn isXmlMimeType;\n&gt; \t\t}\n&gt; \t\t\n&gt; \t\tif (mimeType.equ=\r\nalsIgnoreCase(GENERIC_XML_MIME_TYPE)) {\n&gt; \t\t\tthis.isXmlMimeType =3D true;\n&gt;=\r\n \t\t\tisXmlMimeType =3D true;\n&gt; \t\t} else if (mimeType.equalsIgnoreCase(GENERI=\r\nC_XML_MIME_TYPE_LEGACY)) {\n&gt; \t\t\tthis.isXmlMimeType =3D true;\n&gt; \t\t\tisXmlMime=\r\nType =3D true;\n&gt; \t\t} else if (mimeType.equalsIgnoreCase(ATOM_MIME_TYPE)) {\n=\r\n&gt; \t\t\tthis.isAtomMimeType =3D true;\n&gt; \t\t\tisXmlMimeType =3D true;\n&gt; \t\t} else =\r\nif (mimeType.equalsIgnoreCase(RSS_MIME_TYPE)) {\n&gt; \t\t\tthis.isRssMimeType =3D=\r\n true;\n&gt; \t\t\tisXmlMimeType =3D true;\n&gt; \t\t} else if (mimeType.equalsIgnoreCas=\r\ne(HTML_MIME_TYPE)) {\n&gt; \t\t\tisXmlMimeType =3D true; // Well not really\n&gt; \t\t} =\r\nelse if (mimeType.equalsIgnoreCase(HTML_WITH_CHARSET)) {\n&gt; \t\t\tisXmlMimeType=\r\n =3D true; // Well not really\n&gt; \t\t} else if (mimeType.equalsIgnoreCase(PLAI=\r\nN_MIME_TYPE)) {\n&gt; \t\t\tisXmlMimeType =3D true; // Well not really\n&gt; \t\t}\n&gt;\n&gt; \t=\r\n\t\n&gt; \t\treturn isXmlMimeType;\n&gt; \t}\n&gt; \t\n&gt; \t\n&gt;\n&gt; \t\n&gt;\n&gt;\n&gt; \t// Initialize self he=\r\nre.\n&gt; \tpublic static void main(String args[]) {\n&gt; \t\tString RSS_XML =3D &quot;&lt;?x=\r\nml version=3D&#92;&quot;1.0&#92;&quot;?&gt;&lt;rss version=3D&#92;&quot;2.0&#92;&quot;&gt;&lt;channel&gt;&lt;title&gt;RSS and Atom&lt;/=\r\ntitle&gt;&lt;link&gt;http:// www.benhammersley.com&lt;/link&gt;&lt;description&gt;This is a nice=\r\n RSS 2.0 feed of an even nicer weblog&lt;/description&gt;&lt;/channel&gt;&lt;/rss&gt;&quot;;\n&gt; \t\tS=\r\ntring ATOM_XML =3D &quot;&lt;?xml version=3D&#92;&quot;1.0&#92;&quot; encoding=3D&#92;&quot;utf-8&#92;&quot; ?&gt; &lt;entry =\r\nversion=3D&#92;&quot;draft-ietf-atompub-format-05: do not deploy&#92;&quot; xmlns=3D&#92;&quot;http://=\r\npurl.org/atom/ns#draft-ietf-atompub-format-05&#92;&quot;&gt;&lt;title&gt;Example Entry Docume=\r\nnt&lt;/title&gt; &lt;link rel=3D&#92;&quot;alternate&#92;&quot; type=3D&#92;&quot;text/html&#92;&quot; href=3D&#92;&quot;http://e=\r\nxample.org/example_entry&#92;&quot; hreflang=3D&#92;&quot;en&#92;&quot; title=3D&#92;&quot;Example Entry Docume=\r\nnt&#92;&quot;/&gt;&lt;edit href=3D&#92;&quot;http://example.org/edit?title=3Dexample_entry&#92;&quot;&gt;&lt;autho=\r\nr&gt;&lt;name&gt;Ben Hammersley&lt;/name&gt;&lt;uri&gt;http://www.benhammersley.com&lt;/uri&gt;&lt;email&gt;=\r\nben@...&lt;/email&gt; &lt;contributor&gt;&lt;name&gt;Albert Einstein&lt;/name&gt;&lt;uri=\r\n&gt;http://example.org/~al&lt;/uri&gt;&lt;email&gt;BigAl@...&lt;/email&gt;&lt;/contributor&gt;=\r\n&lt;id&gt;http://example.org/2004/12345678&lt;/id&gt;&lt;updated&gt;2004-10-22T22:08:02Z&lt;/upd=\r\nated&gt;&lt;published&gt;2004-10-22T20:19:02Z&lt;/published&gt;&lt;summary type=3D&#92;&quot;TEXT&#92;&quot;&gt;Th=\r\nis is an example of an Atom Entry Document.&lt;/summary&gt;&lt;content type=3D&#92;&quot;HTML=\r\n&#92;&quot;&gt;&lt;p&gt;&lt;em&gt;This&lt;/em&gt; is an example of an Atom Entry Document.It&#39;s rather nic=\r\ne, don&#92;&#39;t you think?&lt;/p&gt;&lt;/content&gt;   &lt;copyright type=3D&#92;&quot;TEXT&#92;&quot;&gt;This exampl=\r\ne of an Atom Entry Document is hereby granted into the Public Domain&lt;/copyr=\r\night&gt;  &lt;/author&gt; &lt;/edit&gt; &lt;/entry&gt;&quot;;\n&gt; \t\tExtractorXML mySyndFeedExtractor =\r\n=3D new ExtractorXML();\n&gt; \t\tmySyndFeedExtractor.initialTasks();\n&gt; \t\t// mySy=\r\nndFeedExtractor.tpRss(ATOM_XML);\n&gt;\n&gt; \t}\n&gt; }\n\n\n\n\n\n"}}