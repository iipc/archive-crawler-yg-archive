{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":168599281,"authorName":"stack","from":"stack &lt;stack@...&gt;","profile":"stackarchiveorg","replyTo":"LIST","senderId":"2PniHFkZdpoOCKRdUwauYjB2oYRfIk8oKsSZHQ891u-zA0AzhfsocmwnYs5gqN-3FR9O_ZosWENbGJuNf5HJsw","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [archive-crawler] Some improvements for FetchHTTP","postDate":"1108737795","msgId":1585,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQyMTVGRjAzLjEwOTA0MDdAYXJjaGl2ZS5vcmc+","inReplyToHeader":"PDIwMDUwMjE4MTA1NC40OTE4MS5jay1oZXJpdHJpeEBuZXdzY2x1Yi5kZT4=","referencesHeader":"PDIwMDUwMjE3MTQxMi4wNDMxMi5jay1oZXJpdHJpeEBuZXdzY2x1Yi5kZT4gPDQyMTRDQUUyLjUwNDA5MDJAYXJjaGl2ZS5vcmc+IDwyMDA1MDIxODEwNTQuNDkxODEuY2staGVyaXRyaXhAbmV3c2NsdWIuZGU+"},"prevInTopic":1582,"nextInTopic":0,"prevInTime":1584,"nextInTime":1586,"topicId":1574,"numMessagesInTopic":4,"msgSnippet":"... Ok.  Good point. ... For sure. ... Ok.  Probably no harm in sending a Connection: close whatever the HTTP version. ... For Basic Auth 401s, we requeue","rawEmail":"Return-Path: &lt;stack@...&gt;\r\nX-Sender: stack@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 12812 invoked from network); 18 Feb 2005 16:46:03 -0000\r\nReceived: from unknown (66.218.66.217)\n  by m22.grp.scd.yahoo.com with QMQP; 18 Feb 2005 16:46:03 -0000\r\nReceived: from unknown (HELO dns.duboce.net) (63.203.238.114)\n  by mta2.grp.scd.yahoo.com with SMTP; 18 Feb 2005 16:46:02 -0000\r\nReceived: from [192.168.1.125] ([192.168.1.125])\n\t(authenticated)\n\tby dns-eth1.duboce.net (8.10.2/8.10.2) with ESMTP id j1IFu2E19684\n\tfor &lt;archive-crawler@yahoogroups.com&gt;; Fri, 18 Feb 2005 07:56:02 -0800\r\nMessage-ID: &lt;4215FF03.1090407@...&gt;\r\nDate: Fri, 18 Feb 2005 15:43:15 +0100\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.7.5) Gecko/20050105 Debian/1.7.5-1\r\nX-Accept-Language: us, en\r\nMIME-Version: 1.0\r\nTo: archive-crawler@yahoogroups.com\r\nReferences: &lt;200502171412.04312.ck-heritrix@...&gt; &lt;4214CAE2.5040902@...&gt; &lt;200502181054.49181.ck-heritrix@...&gt;\r\nIn-Reply-To: &lt;200502181054.49181.ck-heritrix@...&gt;\r\nContent-Type: text/plain; charset=ISO-8859-1; format=flowed\r\nContent-Transfer-Encoding: 8bit\r\nX-eGroups-Remote-IP: 63.203.238.114\r\nFrom: stack &lt;stack@...&gt;\r\nSubject: Re: [archive-crawler] Some improvements for FetchHTTP\r\nX-Yahoo-Group-Post: member; u=168599281\r\nX-Yahoo-Profile: stackarchiveorg\r\n\r\nChristian Kohlschuetter wrote:\n\n&gt; On Thursday 17 February 2005 17:48, stack wrote:\n&gt; &gt; I&#39;d say we should just decide for the operator which CM to use.  Its\n&gt; &gt; detail an operator need not be concerned with.\n&gt; &gt;\n\n...\n\n&gt; I think, the choosing a CM depends on the crawl scope. Whenever long term\n&gt; (inter-thread) connection reuse is possible (at some later point where we\n&gt; would allow keep-alives), a MultiThreadedHttpConnectionManager would \n&gt; be the\n&gt; best choice.\n\nOk.  Good point.\n\n&gt; ...\n\n&gt;\n&gt; I have attached my ThreadLocalHttpConnectionManager to this mail. \n&gt; Please note\n&gt; that it should remain Apache-licensed as I am probably going to get it\n&gt; incorporated into HttpClient.\n\nFor sure. \n\n&gt;\n&gt; &gt; &gt; - Be polite to the HTTP servers and send the &quot;Range&quot; header, stating\n&gt; (...)\n&gt; &gt; &gt; - Always send a &quot;Connection: close&quot; header\n&gt; &gt;\n&gt; &gt; The above look like good additions but are HTTP/1.1 features when the\n&gt; &gt; crawler is advertising itself as http 1.0.  Are you finding evidence\n&gt; &gt; that they improve the way servers react to the crawler?\n&gt;\n&gt; Yes, I should have stated it explicitly that these headers were \n&gt; HTTP/1.1 :)\n&gt;\n&gt; Even if the request was issued with HTTP/1.0, I sometimes got unwanted\n&gt; &quot;Connection: keep-alive&quot; responses, so sending the &quot;Connection: close&quot; \n&gt; was a\n&gt; solution for me.\n\nOk.  Probably no harm in sending a &#39;Connection: close&#39; whatever the HTTP \nversion.\n\n&gt;\n&gt; Interestingly, after applying the Range header, 36.4% (1,891,996 so \n&gt; far) of\n&gt; all HTTP 2xx responses I got were &quot;206 Partial Content&quot;, so yes, I \n&gt; think it\n&gt; improves behaviour. On the other hand, I just found out that I sometimes\n&gt; (0.039% of all responses) get 416 Request Range Not Satisfiable -- \n&gt; when the\n&gt; Content-Length was 0, for example. In this case, requests have to be \n&gt; reissued\n&gt; (this needs an additional patch, though).\n\nFor Basic Auth 401s, we requeue with a higher priority and let the URL \ncome around again.  You might do same for 416s.  On other hand, \nreissueing the request while still inside FetchHTTP and while connection \nis still up would make a lot of sense.\n\n&gt;\n&gt; Besides that, I somehow feel better to have a correct, but partial \n&gt; response\n&gt; instead of simply cutting a full response after some number of bytes :-)\n\nYes.\n\n\nI&#39;ve added this patch and the fetchhttp improvements to an RFE, &#39;[ \n1143892 ] [contribution] Choice of Connection Manager.&#39;   I&#39;ll try them \nout on this end (It&#39;ll probably be next week before we get to it).\n\nThanks Christian.\nSt.Ack\n\n&gt;\n&gt;\n&gt; Christian\n&gt; -- \n&gt; Christian Kohlschï¿½tter\n&gt; mailto: ck -at- NewsClub.de\n&gt;\n&gt; ------------------------------------------------------------------------\n&gt; *Yahoo! Groups Links*\n&gt;\n&gt;     * To visit your group on the web, go to:\n&gt;       http://groups.yahoo.com/group/archive-crawler/\n&gt;        \n&gt;     * To unsubscribe from this group, send an email to:\n&gt;       archive-crawler-unsubscribe@yahoogroups.com\n&gt;       &lt;mailto:archive-crawler-unsubscribe@yahoogroups.com?subject=Unsubscribe&gt;\n&gt;        \n&gt;     * Your use of Yahoo! Groups is subject to the Yahoo! Terms of\n&gt;       Service &lt;http://docs.yahoo.com/info/terms/&gt;.\n&gt;\n&gt;\n&gt;------------------------------------------------------------------------\n&gt;\n&gt;/**\n&gt; * ====================================================================\n&gt; *\n&gt; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n&gt; *  you may not use this file except in compliance with the License.\n&gt; *  You may obtain a copy of the License at\n&gt; *\n&gt; *      http://www.apache.org/licenses/LICENSE-2.0\n&gt; *\n&gt; *  Unless required by applicable law or agreed to in writing, software\n&gt; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n&gt; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n&gt; *  See the License for the specific language governing permissions and\n&gt; *  limitations under the License.\n&gt; * ====================================================================\n&gt; *\n&gt; */\n&gt;package de.newsclub.httpclient;\n&gt;\n&gt;import java.io.IOException;\n&gt;import java.io.InputStream;\n&gt;import java.util.ArrayList;\n&gt;import java.util.Iterator;\n&gt;import java.util.List;\n&gt;import java.util.logging.Level;\n&gt;import java.util.logging.Logger;\n&gt;\n&gt;import org.apache.commons.httpclient.HostConfiguration;\n&gt;import org.apache.commons.httpclient.HttpConnection;\n&gt;import org.apache.commons.httpclient.HttpConnectionManager;\n&gt;import org.apache.commons.httpclient.params.HttpConnectionManagerParams;\n&gt;\n&gt;/**\n&gt; * A simple, but thread-safe HttpClient {@link HttpConnectionManager}.\n&gt; * Based on {@link org.apache.commons.httpclient.SimpleHttpConnectionManager}.\n&gt; * \n&gt; * &lt;b&gt;Java &gt;= 1.4 is recommended.&lt;/b&gt;\n&gt; * \n&gt; * @author Christian Kohlschuetter \n&gt; */\n&gt;public final class ThreadLocalHttpConnectionManager implements\n&gt;    HttpConnectionManager {\n&gt;\n&gt;    private static final CloserThread closer = new CloserThread();\n&gt;    private static final Logger logger = Logger\n&gt;        .getLogger(ThreadLocalHttpConnectionManager.class.getName());\n&gt;\n&gt;    private final ThreadLocal tl = new ThreadLocal() {\n&gt;        protected synchronized Object initialValue() {\n&gt;            return new ConnectionInfo();\n&gt;        }\n&gt;    };\n&gt;\n&gt;    private ConnectionInfo getConnectionInfo() {\n&gt;        return (ConnectionInfo) tl.get();\n&gt;    }\n&gt;\n&gt;    private final class ConnectionInfo {\n&gt;        /** The http connection */\n&gt;        private HttpConnection conn = null;\n&gt;\n&gt;        /**\n&gt;         * The time the connection was made idle.\n&gt;         */\n&gt;        private long idleStartTime = Long.MAX_VALUE;\n&gt;    }\n&gt;\n&gt;    public ThreadLocalHttpConnectionManager() {\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * Since the same connection is about to be reused, make sure the\n&gt;     * previous request was completely processed, and if not\n&gt;     * consume it now.\n&gt;     * @param conn The connection\n&gt;     * @return true, if the connection is reusable\n&gt;     */\n&gt;    private static boolean finishLastResponse(final HttpConnection conn) {\n&gt;        InputStream lastResponse = conn.getLastResponseInputStream();\n&gt;        if(lastResponse != null) {\n&gt;            conn.setLastResponseInputStream(null);\n&gt;            try {\n&gt;                lastResponse.close();\n&gt;                return true;\n&gt;            } catch (IOException ioe) {\n&gt;                // force reconnect.\n&gt;                return false;\n&gt;            }\n&gt;        } else {\n&gt;            return false;\n&gt;        }\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * Collection of parameters associated with this connection manager.\n&gt;     */\n&gt;    private HttpConnectionManagerParams params = new HttpConnectionManagerParams();\n&gt;\n&gt;    /**\n&gt;     * @see HttpConnectionManager#getConnection(HostConfiguration)\n&gt;     */\n&gt;    public HttpConnection getConnection(\n&gt;        final HostConfiguration hostConfiguration) {\n&gt;        return getConnection(hostConfiguration, 0);\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * Gets the staleCheckingEnabled value to be set on HttpConnections that are created.\n&gt;     * \n&gt;     * @return &lt;code&gt;true&lt;/code&gt; if stale checking will be enabled on HttpConections\n&gt;     * \n&gt;     * @see HttpConnection#isStaleCheckingEnabled()\n&gt;     * \n&gt;     * @deprecated Use {@link HttpConnectionManagerParams#isStaleCheckingEnabled()},\n&gt;     * {@link HttpConnectionManager#getParams()}.\n&gt;     */\n&gt;    public boolean isConnectionStaleCheckingEnabled() {\n&gt;        return this.params.isStaleCheckingEnabled();\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * Sets the staleCheckingEnabled value to be set on HttpConnections that are created.\n&gt;     * \n&gt;     * @param connectionStaleCheckingEnabled &lt;code&gt;true&lt;/code&gt; if stale checking will be enabled \n&gt;     * on HttpConections\n&gt;     * \n&gt;     * @see HttpConnection#setStaleCheckingEnabled(boolean)\n&gt;     * \n&gt;     * @deprecated Use {@link HttpConnectionManagerParams#setStaleCheckingEnabled(boolean)},\n&gt;     * {@link HttpConnectionManager#getParams()}.\n&gt;     */\n&gt;    public void setConnectionStaleCheckingEnabled(\n&gt;        final boolean connectionStaleCheckingEnabled) {\n&gt;        this.params.setStaleCheckingEnabled(connectionStaleCheckingEnabled);\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * @see HttpConnectionManager#getConnectionWithTimeout(HostConfiguration, long)\n&gt;     * \n&gt;     * @since 3.0\n&gt;     */\n&gt;    public HttpConnection getConnectionWithTimeout(\n&gt;        final HostConfiguration hostConfiguration, final long timeout) {\n&gt;\n&gt;        final ConnectionInfo ci = getConnectionInfo();\n&gt;        HttpConnection httpConnection = ci.conn;\n&gt;\n&gt;        // make sure the host and proxy are correct for this connection\n&gt;        // close it and set the values if they are not\n&gt;        if(httpConnection == null || !finishLastResponse(httpConnection)\n&gt;            || !hostConfiguration.hostEquals(httpConnection)\n&gt;            || !hostConfiguration.proxyEquals(httpConnection)) {\n&gt;\n&gt;            if(httpConnection != null && httpConnection.isOpen()) {\n&gt;                closer.closeConnection(httpConnection);\n&gt;            }\n&gt;\n&gt;            httpConnection = new HttpConnection(hostConfiguration);\n&gt;            httpConnection.setHttpConnectionManager(this);\n&gt;            httpConnection.getParams().setDefaults(this.params);\n&gt;            ci.conn = httpConnection;\n&gt;\n&gt;            httpConnection.setHost(hostConfiguration.getHost());\n&gt;            httpConnection.setPort(hostConfiguration.getPort());\n&gt;            httpConnection.setProtocol(hostConfiguration.getProtocol());\n&gt;            httpConnection.setLocalAddress(hostConfiguration.getLocalAddress());\n&gt;\n&gt;            httpConnection.setProxyHost(hostConfiguration.getProxyHost());\n&gt;            httpConnection.setProxyPort(hostConfiguration.getProxyPort());\n&gt;        }\n&gt;\n&gt;        // remove the connection from the timeout handler\n&gt;        ci.idleStartTime = Long.MAX_VALUE;\n&gt;\n&gt;        return httpConnection;\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * @see HttpConnectionManager#getConnection(HostConfiguration, long)\n&gt;     * \n&gt;     * @deprecated Use #getConnectionWithTimeout(HostConfiguration, long)\n&gt;     */\n&gt;    public HttpConnection getConnection(\n&gt;        final HostConfiguration hostConfiguration, final long timeout) {\n&gt;        return getConnectionWithTimeout(hostConfiguration, timeout);\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * @see HttpConnectionManager#releaseConnection(org.apache.commons.httpclient.HttpConnection)\n&gt;     */\n&gt;    public void releaseConnection(final HttpConnection conn) {\n&gt;        final ConnectionInfo ci = getConnectionInfo();\n&gt;        HttpConnection httpConnection = ci.conn;\n&gt;\n&gt;        if(conn != httpConnection) {\n&gt;            throw new IllegalStateException(\n&gt;                &quot;Unexpected release of an unknown connection.&quot;);\n&gt;        }\n&gt;\n&gt;        finishLastResponse(httpConnection);\n&gt;\n&gt;        // track the time the connection was made idle\n&gt;        ci.idleStartTime = System.currentTimeMillis();\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * Returns {@link HttpConnectionManagerParams parameters} associated \n&gt;     * with this connection manager.\n&gt;     * \n&gt;     * @since 2.1\n&gt;     * \n&gt;     * @see HttpConnectionManagerParams\n&gt;     */\n&gt;    public HttpConnectionManagerParams getParams() {\n&gt;        return this.params;\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * Assigns {@link HttpConnectionManagerParams parameters} for this \n&gt;     * connection manager.\n&gt;     * \n&gt;     * @since 2.1\n&gt;     * \n&gt;     * @see HttpConnectionManagerParams\n&gt;     */\n&gt;    public void setParams(final HttpConnectionManagerParams p) {\n&gt;        if(p == null) {\n&gt;            throw new IllegalArgumentException(&quot;Parameters may not be null&quot;);\n&gt;        }\n&gt;        this.params = p;\n&gt;    }\n&gt;\n&gt;    /**\n&gt;     * @since 3.0\n&gt;     */\n&gt;    public void closeIdleConnections(final long idleTimeout) {\n&gt;        long maxIdleTime = System.currentTimeMillis() - idleTimeout;\n&gt;\n&gt;        final ConnectionInfo ci = getConnectionInfo();\n&gt;\n&gt;        if(ci.idleStartTime &lt;= maxIdleTime) {\n&gt;            ci.conn.close();\n&gt;        }\n&gt;    }\n&gt;\n&gt;    private static final class CloserThread extends Thread {\n&gt;        private List connections = new ArrayList();\n&gt;        private static final int SLEEP_INTERVAL = 5000;\n&gt;\n&gt;        public CloserThread() {\n&gt;            super(&quot;HttpConnection closer&quot;);\n&gt;            start();\n&gt;        }\n&gt;\n&gt;        public void closeConnection(final HttpConnection conn) {\n&gt;            synchronized (connections) {\n&gt;                connections.add(conn);\n&gt;            }\n&gt;        }\n&gt;\n&gt;        public void run() {\n&gt;            try {\n&gt;                while (!Thread.interrupted()) {\n&gt;                    Thread.sleep(SLEEP_INTERVAL);\n&gt;\n&gt;                    List s;\n&gt;                    synchronized (connections) {\n&gt;                        s = connections;\n&gt;                        connections = new ArrayList();\n&gt;                    }\n&gt;                    logger.log(Level.INFO, &quot;Closing &quot; + s.size()\n&gt;                        + &quot; HttpConnections&quot;);\n&gt;                    for(final Iterator it = s.iterator(); it.hasNext();) {\n&gt;                        HttpConnection conn = (HttpConnection) it.next();\n&gt;                        conn.close();\n&gt;                        conn.setHttpConnectionManager(null);\n&gt;                        it.remove();\n&gt;                    }\n&gt;                }\n&gt;            } catch (InterruptedException e) {\n&gt;                return;\n&gt;            }\n&gt;        }\n&gt;    }\n&gt;}\n&gt;  \n&gt;\n\n\n"}}