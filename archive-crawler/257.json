{"ygPerms":{"resourceCapabilityList":[{"resourceType":"GROUP","capabilities":[{"name":"READ"},{"name":"JOIN"}]},{"resourceType":"PHOTO","capabilities":[]},{"resourceType":"FILE","capabilities":[]},{"resourceType":"MEMBER","capabilities":[]},{"resourceType":"LINK","capabilities":[]},{"resourceType":"CALENDAR","capabilities":[]},{"resourceType":"DATABASE","capabilities":[]},{"resourceType":"POLL","capabilities":[]},{"resourceType":"MESSAGE","capabilities":[{"name":"READ"}]},{"resourceType":"PENDING_MESSAGE","capabilities":[]},{"resourceType":"ATTACHMENTS","capabilities":[{"name":"READ"}]},{"resourceType":"PHOTOMATIC_ALBUMS","capabilities":[]},{"resourceType":"MEMBERSHIP_TYPE","capabilities":[]},{"resourceType":"POST","capabilities":[{"name":"READ"}]},{"resourceType":"PIN","capabilities":[]}],"groupUrl":"groups.yahoo.com","intlCode":"us"},"comscore":"pageview_candidate","ygData":{"userId":168599281,"authorName":"Michael Stack","from":"Michael Stack &lt;stack@...&gt;","replyTo":"LIST","senderId":"FE8dqY86Bh2nOLcdWZ7x68eWIciVZD3LDfLAp5V2igFzuz3xCfXP_cS1Entpbmvur-mEd9H_Ecm2Lqn1C6NgNkrGr8z8ufGK","spamInfo":{"isSpam":false,"reason":"0"},"subject":"Re: [archive-crawler] Heritrix Checkpointing High-Level Design","postDate":"1074824553","msgId":257,"canDelete":false,"contentTrasformed":false,"systemMessage":false,"headers":{"messageIdInHeader":"PDQwMTA4NTY5LjYwNjAxQGFyY2hpdmUub3JnPg==","inReplyToHeader":"PDQwMERBMjRELjMwMjA0MDNAYXJjaGl2ZS5vcmc+","referencesHeader":"PDQwMERBMjRELjMwMjA0MDNAYXJjaGl2ZS5vcmc+"},"prevInTopic":244,"nextInTopic":258,"prevInTime":256,"nextInTime":258,"topicId":244,"numMessagesInTopic":13,"msgSnippet":"See below for a couple of notes, mostly questions. ...  ... Can we quantify what would be acceptable duplication? ... Do we know how to identify a","rawEmail":"Return-Path: &lt;stack@...&gt;\r\nX-Sender: stack@...\r\nX-Apparently-To: archive-crawler@yahoogroups.com\r\nReceived: (qmail 10768 invoked from network); 23 Jan 2004 02:28:38 -0000\r\nReceived: from unknown (66.218.66.172)\n  by m8.grp.scd.yahoo.com with QMQP; 23 Jan 2004 02:28:38 -0000\r\nReceived: from unknown (HELO ia00524.archive.org) (209.237.232.202)\n  by mta4.grp.scd.yahoo.com with SMTP; 23 Jan 2004 02:28:38 -0000\r\nReceived: (qmail 7771 invoked by uid 100); 23 Jan 2004 02:26:23 -0000\r\nReceived: from b116-dyn-60.archive.org (HELO archive.org) (stack@...@209.237.240.60)\n  by mail-dev.archive.org with SMTP; 23 Jan 2004 02:26:23 -0000\r\nMessage-ID: &lt;40108569.60601@...&gt;\r\nDate: Thu, 22 Jan 2004 18:22:33 -0800\r\nUser-Agent: Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.5) Gecko/20031007\r\nX-Accept-Language: en-us, en\r\nMIME-Version: 1.0\r\nTo: archive-crawler@yahoogroups.com\r\nReferences: &lt;400DA24D.3020403@...&gt;\r\nIn-Reply-To: &lt;400DA24D.3020403@...&gt;\r\nContent-Type: text/plain; charset=windows-1252; format=flowed\r\nContent-Transfer-Encoding: 7bit\r\nX-Spam-DCC: : \r\nX-Spam-Checker-Version: SpamAssassin 2.63 (2004-01-11) on ia00524.archive.org\r\nX-Spam-Level: \r\nX-Spam-Status: No, hits=-3.5 required=6.0 tests=AWL,BAYES_00 autolearn=ham \n\tversion=2.63\r\nX-eGroups-Remote-IP: 209.237.232.202\r\nFrom: Michael Stack &lt;stack@...&gt;\r\nSubject: Re: [archive-crawler] Heritrix Checkpointing High-Level Design\r\nX-Yahoo-Group-Post: member; u=168599281\r\n\r\nSee below for a couple of notes, mostly questions.\n\nGordon Mohr wrote:\n\n&gt;BACKGROUND/REQUIREMENTS:\n&gt;  \n&gt;\n&lt;--CUT--&gt;\n\n&gt;  - Erring slightly on the side of duplication/revisitation,\n&gt;    in logs or ARC files, is acceptable for our purposes,\n&gt;    if it otherwise simplifies or accelerates the process.\n&gt;\n&gt;  \n&gt;\nCan we quantify what would be acceptable duplication?\n\n&gt;  - When an individual worker ToeThread hangs or\n&gt;    spins indefinitely in an uninterruptible manner,\n&gt;    we will accept whatever small inconsistency\n&gt;    might be introduced by ignoring its status and\n&gt;    going forward with a checkpoint. (For example,\n&gt;    if a buggy Processor at any point in the chain\n&gt;    never completes, checkpointing should still\n&gt;    be possible, the problem-causing URI should be\n&gt;    noted, and our data may suffer side effects of its\n&gt;    partial processing.)\n&gt;  \n&gt;\nDo we know how to identify a spinning uninterruptable thread \nprogrammatically or is this something a human does?  Will checkpointing \nbe able to proceed though a thread is unreachable (spinning, \nuninterruptable)?  How will it know to skip the problematic thread?\n\n&gt;  - Logs begin in new files upon each checkpoint; to\n&gt;    see the log over the whole crawl, the files must\n&gt;    be concatenated. (This makes checkpointing easier\n&gt;    but some of the log-viewing admin UI harder.) The\n&gt;    Mercator approach is to name the current logs\n&gt;    LOGNAME.tmp, then rename them LOGNAME.00001, etc.,\n&gt;    after each checkpoint, and we will adopt this\n&gt;    same convention.\n&gt;  \n&gt;\nSo all logs for a crawl will be available under the logging directory?  \nWe don&#39;t want to rotate them out on a period?  Will the UI be expected \nto open massive log files (or rather should the UI just show reporting \ngenerated off data logged)?\n\n&gt;And further a simplifications we&#39;ll accept for the\n&gt;initial implementation:\n&gt;\n&gt;  - Checkpointing in progress may noticeably halt\n&gt;    crawler progress; essentially all in-progress URIs\n&gt;    must complete their processing (or time out) before\n&gt;    a checkpoint proceeds. (We will refine this to\n&gt;    minimize the crawler-pause time as possible.)\n&gt;\n&gt;CHECKPOINT OVERVIEW\n&gt;\n&gt;Crawl operator perspective:\n&gt;\n&gt;UI reflects a &quot;next checkpoint will be&quot; number. Operator\n&gt;requests a checkpoint. UI reflects that checkpoint is in\n&gt;progress. Checkpoint may take many minutes. Upon completion,\n&gt;checkpoint summary info is available in a list of checkpoints\n&gt;among the other crawl reports. A subdirectory of the main\n&gt;crawl output directory holds all generated checkpoint info.\n&gt;Copying that directory to a remote location is sufficient\n&gt;to restart the crawl later.\n&gt;\n&gt;When user wants to resume from a checkpoint, they can\n&gt;browse a list of all known checkpoints (or point crawler\n&gt;to a previously unknown checkpoint). Checkpoint is\n&gt;first loaded in &#39;paused&#39; mode, allowing state to be\n&gt;viewed and paramters to be tuned. Then, crawl can be\n&gt;resumed on request. \n&gt;\nAt what points during crawling can this above operation be done?  At any \npoint?  Or just at pause after startup?  Will it be possible for \noperator to load a checkpoint while crawler is running (And if so, how \ndoes this work)?\n\n&gt;Previous post-checkpoint output may\n&gt;be clobbered in-place. (For example, when resuming\n&gt;checkpoint 00004, previous files that were building\n&gt;towards old checkpoint 00005 will be overwritten.)\n&gt;\n&gt;In the code:\n&gt;\n&gt;CrawlController receives a checkpoint request. A flag\n&gt;is set indicating the control thread should initiate a\n&gt;checkpoint.\n&gt;\n&gt;No further URIs are emitted from the Frontier for\n&gt;processing. The checkpoint routine, in the main control\n&gt;thread, waits for all ToeThreads to complete their\n&gt;current URIs, subject to a maximum wait. (Any URIs still\n&gt;in process at the end of the wait period are noted as\n&gt;problematic -- and logged as either special errors or\n&gt;returned to the Frontier.)\n&gt;\n&gt;The checkpoint begins: each notable component of\n&gt;the system -- implementers of the Checkpointable\n&gt;interface -- are sent the prepare(checkpointNumber,\n&gt;storeDirectory) message. As necessary, they pass\n&gt;this to their subcomponents.\n&gt;  \n&gt;\n\nHow will you find all implementers of the Checkpointable interface?  Can \nany old POJO implement Checkpointable or is it only processors?\n\n\n(Is there a facilty for pausing a crawl or stopping a crawl?  If so, how \nis that done?)\n\nIs it completely up to the Checkpointable implementer how they checkpoint?\n\n&gt;Generally, the checkpointing of an object involves:\n&gt;  (1) Writing its important in-memory state to\n&gt;      one or more files.\n&gt;  \n&gt;\n&gt;  (2) Duplicating any on-disk state to the checkpoint\n&gt;      directory. (In some cases, this may be possible\n&gt;      with filesystem hard-links rather than actual\n&gt;      copies.)\n&gt;  \n&gt;\nDo you have examples of the above to illustrate how it would work?\n\n&gt;To resume from a checkpoint, the CrawlController would\n&gt;receive a resume-request with an origin directory. It\n&gt;would reconstitute the parts of the crawl, primarily by\n&gt;constructing new instances which read their state from\n&gt;the origin directory, copying data as necessary to the\n&gt;&quot;running&quot; disk space. (A resume should not alter the\n&gt;stored checkpoint in any way.)\n&gt;  \n&gt;\nThe origin directory points at the checkpoint we want to resume from?\n\n&gt;CHECKPOINT FRAMEWORK\n&gt;\n&gt;Each ToeThread wraps its per-URI processing with:\n&gt;\n&gt;    crawlLock.acquireShared(); // crawlLock is a shared-exclusive\n&gt;                               // (AKA &#39;readwrite&#39;) lock\n&gt;    // all processing\n&gt;    crawlLock.releaseShared();\n&gt;\n&gt;(This lock may be refined later to leave out early\n&gt;processing stages, possibly up through fetching,\n&gt;which can be harmlessly considered to never have\n&gt;begun.)\n&gt;\n&gt;The CrawlController controlThread, when it detects\n&gt;a checkpoint has been requested, runs a checkpoint\n&gt;rountine which is roughly:\n&gt;\n&gt;    crawlLock.acquireExclusive();\n&gt;    versionId++;\n&gt;    prepare(versionId, checkpointDirectory); // actually does the checkpointing, passing\n&gt;                                             // prepare() calls to subcomponents\n&gt;    commit(versionId, checkpointDirectory);  // marks the checkpoint as complete, cleans up\n&gt;  \n&gt;\n&gt;    crawlLock.releaseExclusive();\n&gt;  \n&gt;\n\nAre you missing a resume here?\n\nOtherwise, it looks good.\nSt.Ack\n\n&gt;Key parts of the system, starting with CrawlController,\n&gt;implement interface Checkpointable, which includes\n&gt;methods:\n&gt;  - prepare(int versionId, File checkpointDirectory)\n&gt;  - commit(int versionId, File checkpointDirectory)\n&gt;  - resume(File originDirectory)\n&gt;\n&gt;IMPLICATIONS ACROSS CODE\n&gt;\n&gt;Of course, every component which must recover its running\n&gt;state to enable a resume-from-checkpoint must implement\n&gt;Checkpointable and have the proper Checkpointable methods\n&gt;called from the other components which bind it to the\n&gt;CrawlController.\n&gt;\n&gt;The Web UI will require instrumentation for setting\n&gt;checkpoint intervals, manually triggering checkpoints,\n&gt;listing available checkpoints, and triggering resumes.\n&gt;\n&gt;- Gordon\n&gt;\n&gt; \n&gt;\n&gt;Yahoo! Groups Links\n&gt;\n&gt;To visit your group on the web, go to:\n&gt; http://groups.yahoo.com/group/archive-crawler/\n&gt;\n&gt;To unsubscribe from this group, send an email to:\n&gt; archive-crawler-unsubscribe@yahoogroups.com\n&gt;\n&gt;Your use of Yahoo! Groups is subject to:\n&gt; http://docs.yahoo.com/info/terms/ \n&gt;\n&gt;\n&gt;  \n&gt;\n\n\n\n"}}